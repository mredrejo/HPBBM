[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HPBBM2023",
    "section": "",
    "text": "There are only two kinds of programming languages: the ones people complain about and the ones nobody uses. —Bjarne Stroustrup"
  },
  {
    "objectID": "index.html#wellcome-disclaimer",
    "href": "index.html#wellcome-disclaimer",
    "title": "HPBBM2023",
    "section": "Wellcome & Disclaimer",
    "text": "Wellcome & Disclaimer\n\n\n\n\n\n\nUnder construction\n\n\n\n\n\n\n\n\n\n\nLogo generated with hexSticker package.1\n\n\n\nThis site contains the materials for the Coding tools for Biochemistry & Molecular Biology (Herramientas de Programación para Bioquímica y Biología Molecular, a.k.a. HPBBM) course of fall 2023 in the Bachelor’s Degree in Biochemistry @UAM (Universidad Autónoma de Madrid, Spain). Source files are available at the  repo, containing the source files and the data used in the examples and exercises. The icon  on the top-right corner in all the site pages will allow you to download the repo data folder (link generated with DownGit). Note that this folder can be updated during the course. For reference, materials from 2022 course edition are available in the HPBBM2022 site.\nCourse Syllabus can be checked at UAM site and a PDF version is available here. The course contains a first block of lessons on Python programming (Lessons 1-7) and a Python-vs-R introductory lessons (Lessons R1 & R2) that are not included here. Detailed academic information about the course contents, dates, and assessment only can be found at the UAM Moodle site. In this site, the lessons pages have been generated as Quarto to obtain source files (.qmd) that contain formatted text and chunks of R code that are executed upon rendering (see lesson R7 for more info about Markdown and Quarto in RStudio).\n\n\n\n\n\n\nHow to use this site\n\n\n\nThese materials were designed to be an interactive resource. Think about the code and test it with your computer.\n\n\n\n\n\n\n\n\nUpdate R and RStudio\n\n\n\nAll the Lessons contain a final R Session info where you can see the used versions for R and all packages. Anyway, espacially if you installed R in your computer for the first time some years ago, I kindly request to update R and RStudio before going forward.\n\n\nLessons also contain embedded interactive short exercises (generated with learnr y/o webexercises packages). Try them before checking the proposed solution. Also, we included a final section of Review exercises, some of them from freely available online solved exercises and others that we created. The answers to the latter are not available online, but I’ll be glad to provide them upon request.\nAll this material is open access and it is shared under CC BY-NC license.\nThis is a draft version of this site, but it is intended to be expanded and corrected throughout the next weeks and new versions will be available the following years. Any feedback, help, or suggestions will be very warmly welcome.\nAlso, it is likely that you find some mistypes or even some big mistakes throughout these course materials. I, and the future students, will appreciate it if you let me know about anything that could be corrected or just improved. You can reach me by email."
  },
  {
    "objectID": "index.html#bibliography-and-resources",
    "href": "index.html#bibliography-and-resources",
    "title": "HPBBM2023",
    "section": "Bibliography and Resources",
    "text": "Bibliography and Resources\nEach lesson contains its own specific references, but I wanted to highlight here some curated general open access and open source resources to introduce yourself into R and R Studio.\n\nGrolemund, G. Hands-on Programming in R.\nPeng, R. D. R Programming for Data Science.\nCoulatti, R. I. R Crash Course for Biologist.\nChang, W. R. R Graphics Cookbook.\nDoyle, M., Chung, J. & Perreau V. Introduction to R for Biologists.\nLearn R by example"
  },
  {
    "objectID": "index.html#contents",
    "href": "index.html#contents",
    "title": "HPBBM2023",
    "section": "Contents",
    "text": "Contents\n\nLesson R1: Variables, data objects and data types in R\n\n\nLesson R2: Flow Control in R\n\n\nLesson R3: Data input and output in R\n\n\nLesson R4: Write your own functions\n\n\nLesson R5: Plots\n\n\nLesson R6: Data management\n\n\nLesson R7: R-projects and R-markdown for reproducible data analysis\n\n\nLesson R8: Advanced data plotting with ggplot\n\n\nLesson R9: Applications for Molecular Biology"
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "HPBBM2023",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee the code in the script r_sticker.R in the repo.↩︎"
  },
  {
    "objectID": "r3.html",
    "href": "r3.html",
    "title": "R3: Read and write data in R",
    "section": "",
    "text": "As you already know, launching R starts an interactive session with input from the keyboard and output on the screen. If you are using small datasets, you can define and enter your data directly in the Console, as you did in the examples before. Also, you can define your objects and enter your data interactively with the functions scan() and readline() as in the examples below. Regarding the output, you can just call the object by its name or use the function print(), which displays on the screen the contents of its argument object. You can try the code below.1\n\nvector &lt;- scan(n = 4)\nvector2 &lt;- scan()\nstr &lt;- readline()\nvector\nprint(vector2)\nprint(str)\nedit(str)\n\nAlthough, seldom used, you can also edit the contents of your objects using the function edit(). This function can be used to edit different objects, including vectors, strings, matrices or dataframes. MacOS users may need to install XQuartz X11 tool."
  },
  {
    "objectID": "r3.html#explore-a-dataframe",
    "href": "r3.html#explore-a-dataframe",
    "title": "R3: Read and write data in R",
    "section": "4.1 Explore a dataframe",
    "text": "4.1 Explore a dataframe\nAs you can see in the R help, the function read.table() has several default options as FALSE, like header=FALSE. When you have a spreadsheet export file, i.e. having a table where the fields are divided by commas in place of spaces, you can use read.csv() in place of read.table(). For Spaniards, there is also read.csv2(), which uses a comma for the decimal point and a semicolon for the separator. The latter functions are wrappers of read.table() with custom default options. Likewise, there are write.csv() and write.csv2(), which are wrappers of write.table().\n\n# Note differences between read.table(), read.csv() and\n# read.csv2()\ncoli_genomes &lt;- read.table(file = \"data/coli_genomes.csv\")\n\nError in scan(file = file, what = what, sep = sep, quote = quote, dec = dec, : line 2 did not have 11 elements\n\nhead(coli_genomes)\n\nError in eval(expr, envir, enclos): object 'coli_genomes' not found\n\ncoli_genomes &lt;- read.table(file = \"data/coli_genomes.csv\", sep = \";\",\n    dec = \".\", header = TRUE)\nhead(coli_genomes)\n\n   Strain    Biosample Year.of.isolation   Source Phylogroup Serotype Clonotype\n1 LREC237 SAMN14278613                NA   Human           D  ONT:H28  CH23-331\n2 LREC239 SAMN14278614              2010   Human           C O153:H19    CH4-25\n3 LREC240 SAMN14278615              2008   Human          B1  O76:H30   CH29-38\n4 LREC241 SAMN14278616                NA    Human          A  O78:H11   CH11-41\n5 LREC242 SAMN14278617              2011 Porcine           A  ONT:HNM    CH7-54\n6 LREC243 SAMN14278618              2007 Porcine           A   O9:H37    CH7-31\n  Sequence.Type VF No..Plasmids kmer Contigs    N50 longest.contig..bp.\n1         ST524 18            3  117     223 272287              662555\n2          ST88 14            3  117     159 323172              760527\n3         ST156 10            2   89     114 270767              738861\n4          ST48  5            3  117     212 112160              285056\n5         ST746  5            9   89     320  45936              128053\n6        ST3011  7            3   93     158 106897              369508\n  total.assembled.bp contigs...1kb\n1            5341632            74\n2            5415613            57\n3            4875343            47\n4            5167401           101\n5            4858138           212\n6            4638334            93\n\ncoli_genomes &lt;- read.csv(file = \"data/coli_genomes.csv\")\nhead(coli_genomes)\n\n  Strain.Biosample.Year.of.isolation.Source.Phylogroup.Serotype.Clonotype.Sequence.Type.VF.No..Plasmids.kmer.Contigs.N50.longest.contig..bp..total.assembled.bp.contigs...1kb\n1                                                                               LREC237;SAMN14278613;NA;Human ;D;ONT:H28;CH23-331;ST524;18;3;117;223;272287;662555;5341632;74\n2                                                                               LREC239;SAMN14278614;2010;Human ;C;O153:H19;CH4-25;ST88;14;3;117;159;323172;760527;5415613;57\n3                                                                              LREC240;SAMN14278615;2008;Human ;B1;O76:H30;CH29-38;ST156;10;2;89;114;270767;738861;4875343;47\n4                                                                                  LREC241;SAMN14278616;NA;Human;A;O78:H11;CH11-41;ST48;5;3;117;212;112160;285056;5167401;101\n5                                                                               LREC242;SAMN14278617;2011;Porcine ;A;ONT:HNM;CH7-54;ST746;5;9;89;320;45936;128053;4858138;212\n6                                                                               LREC243;SAMN14278618;2007;Porcine ;A;O9:H37;CH7-31;ST3011;7;3;93;158;106897;369508;4638334;93\n\ncoli_genomes &lt;- read.csv(file = \"data/coli_genomes.csv\", sep = \";\")\nhead(coli_genomes)\n\n   Strain    Biosample Year.of.isolation   Source Phylogroup Serotype Clonotype\n1 LREC237 SAMN14278613                NA   Human           D  ONT:H28  CH23-331\n2 LREC239 SAMN14278614              2010   Human           C O153:H19    CH4-25\n3 LREC240 SAMN14278615              2008   Human          B1  O76:H30   CH29-38\n4 LREC241 SAMN14278616                NA    Human          A  O78:H11   CH11-41\n5 LREC242 SAMN14278617              2011 Porcine           A  ONT:HNM    CH7-54\n6 LREC243 SAMN14278618              2007 Porcine           A   O9:H37    CH7-31\n  Sequence.Type VF No..Plasmids kmer Contigs    N50 longest.contig..bp.\n1         ST524 18            3  117     223 272287              662555\n2          ST88 14            3  117     159 323172              760527\n3         ST156 10            2   89     114 270767              738861\n4          ST48  5            3  117     212 112160              285056\n5         ST746  5            9   89     320  45936              128053\n6        ST3011  7            3   93     158 106897              369508\n  total.assembled.bp contigs...1kb\n1            5341632            74\n2            5415613            57\n3            4875343            47\n4            5167401           101\n5            4858138           212\n6            4638334            93\n\ncoli_genomes &lt;- read.csv2(file = \"data/coli_genomes.csv\")\nhead(coli_genomes)\n\n   Strain    Biosample Year.of.isolation   Source Phylogroup Serotype Clonotype\n1 LREC237 SAMN14278613                NA   Human           D  ONT:H28  CH23-331\n2 LREC239 SAMN14278614              2010   Human           C O153:H19    CH4-25\n3 LREC240 SAMN14278615              2008   Human          B1  O76:H30   CH29-38\n4 LREC241 SAMN14278616                NA    Human          A  O78:H11   CH11-41\n5 LREC242 SAMN14278617              2011 Porcine           A  ONT:HNM    CH7-54\n6 LREC243 SAMN14278618              2007 Porcine           A   O9:H37    CH7-31\n  Sequence.Type VF No..Plasmids kmer Contigs    N50 longest.contig..bp.\n1         ST524 18            3  117     223 272287              662555\n2          ST88 14            3  117     159 323172              760527\n3         ST156 10            2   89     114 270767              738861\n4          ST48  5            3  117     212 112160              285056\n5         ST746  5            9   89     320  45936              128053\n6        ST3011  7            3   93     158 106897              369508\n  total.assembled.bp contigs...1kb\n1            5341632            74\n2            5415613            57\n3            4875343            47\n4            5167401           101\n5            4858138           212\n6            4638334            93\n\n# read some data\nhead(coli_genomes)\n\n   Strain    Biosample Year.of.isolation   Source Phylogroup Serotype Clonotype\n1 LREC237 SAMN14278613                NA   Human           D  ONT:H28  CH23-331\n2 LREC239 SAMN14278614              2010   Human           C O153:H19    CH4-25\n3 LREC240 SAMN14278615              2008   Human          B1  O76:H30   CH29-38\n4 LREC241 SAMN14278616                NA    Human          A  O78:H11   CH11-41\n5 LREC242 SAMN14278617              2011 Porcine           A  ONT:HNM    CH7-54\n6 LREC243 SAMN14278618              2007 Porcine           A   O9:H37    CH7-31\n  Sequence.Type VF No..Plasmids kmer Contigs    N50 longest.contig..bp.\n1         ST524 18            3  117     223 272287              662555\n2          ST88 14            3  117     159 323172              760527\n3         ST156 10            2   89     114 270767              738861\n4          ST48  5            3  117     212 112160              285056\n5         ST746  5            9   89     320  45936              128053\n6        ST3011  7            3   93     158 106897              369508\n  total.assembled.bp contigs...1kb\n1            5341632            74\n2            5415613            57\n3            4875343            47\n4            5167401           101\n5            4858138           212\n6            4638334            93\n\ntail(coli_genomes, n = 2)\n\n    Strain    Biosample Year.of.isolation Source Phylogroup Serotype Clonotype\n24 LREC261 SAMN14278636              2016 Human           A  O98:H26   CH27-23\n25 LREC262 SAMN14278637              2012 Human          B1  O66:H10    CH4-32\n   Sequence.Type VF No..Plasmids kmer Contigs    N50 longest.contig..bp.\n24        ST8233  2            4   89     114 187945              537848\n25        ST1049  4            2  113      94 325747              822206\n   total.assembled.bp contigs...1kb\n24            4821342            53\n25            4839344            32\n\ncoli_genomes[1, ]\n\n   Strain    Biosample Year.of.isolation Source Phylogroup Serotype Clonotype\n1 LREC237 SAMN14278613                NA Human           D  ONT:H28  CH23-331\n  Sequence.Type VF No..Plasmids kmer Contigs    N50 longest.contig..bp.\n1         ST524 18            3  117     223 272287              662555\n  total.assembled.bp contigs...1kb\n1            5341632            74\n\ncoli_genomes[, 1]\n\n [1] \"LREC237\" \"LREC239\" \"LREC240\" \"LREC241\" \"LREC242\" \"LREC243\" \"LREC244\"\n [8] \"LREC245\" \"LREC246\" \"LREC247\" \"LREC248\" \"LREC249\" \"LREC250\" \"LREC251\"\n[15] \"LREC252\" \"LREC253\" \"LREC254\" \"LREC255\" \"LREC256\" \"LREC257\" \"LREC258\"\n[22] \"LREC259\" \"LREC260\" \"LREC261\" \"LREC262\"\n\ncoli_genomes[1:6, 2:4]\n\n     Biosample Year.of.isolation   Source\n1 SAMN14278613                NA   Human \n2 SAMN14278614              2010   Human \n3 SAMN14278615              2008   Human \n4 SAMN14278616                NA    Human\n5 SAMN14278617              2011 Porcine \n6 SAMN14278618              2007 Porcine \n\n# explore the dataframe structure\ndim(coli_genomes)\n\n[1] 25 16\n\nlength(coli_genomes)\n\n[1] 16\n\nncol(coli_genomes)\n\n[1] 16\n\nnrow(coli_genomes)\n\n[1] 25\n\n# dataframe estructure in one line\nstr(coli_genomes)\n\n'data.frame':   25 obs. of  16 variables:\n $ Strain             : chr  \"LREC237\" \"LREC239\" \"LREC240\" \"LREC241\" ...\n $ Biosample          : chr  \"SAMN14278613\" \"SAMN14278614\" \"SAMN14278615\" \"SAMN14278616\" ...\n $ Year.of.isolation  : int  NA 2010 2008 NA 2011 2007 2006 2006 2010 2013 ...\n $ Source             : chr  \"Human \" \"Human \" \"Human \" \"Human\" ...\n $ Phylogroup         : chr  \"D\" \"C\" \"B1\" \"A\" ...\n $ Serotype           : chr  \"ONT:H28\" \"O153:H19\" \"O76:H30\" \"O78:H11\" ...\n $ Clonotype          : chr  \"CH23-331\" \"CH4-25\" \"CH29-38\" \"CH11-41\" ...\n $ Sequence.Type      : chr  \"ST524\" \"ST88\" \"ST156\" \"ST48\" ...\n $ VF                 : int  18 14 10 5 5 7 4 2 10 22 ...\n $ No..Plasmids       : int  3 3 2 3 9 3 7 7 1 4 ...\n $ kmer               : int  117 117 89 117 89 93 115 115 113 113 ...\n $ Contigs            : int  223 159 114 212 320 158 277 203 131 215 ...\n $ N50                : int  272287 323172 270767 112160 45936 106897 89185 94368 326769 248158 ...\n $ longest.contig..bp.: int  662555 760527 738861 285056 128053 369508 281444 280268 451887 504233 ...\n $ total.assembled.bp : int  5341632 5415613 4875343 5167401 4858138 4638334 5406295 4796593 5173794 5364777 ...\n $ contigs...1kb      : int  74 57 47 101 212 93 155 114 56 76 ...\n\n# type of data in each variable\ntypeof(coli_genomes$Strain)\n\n[1] \"character\"\n\ntypeof(coli_genomes[, 2])\n\n[1] \"character\"\n\ntypeof(coli_genomes[, 9])\n\n[1] \"integer\"\n\n# col and row names\nnames(coli_genomes)\n\n [1] \"Strain\"              \"Biosample\"           \"Year.of.isolation\"  \n [4] \"Source\"              \"Phylogroup\"          \"Serotype\"           \n [7] \"Clonotype\"           \"Sequence.Type\"       \"VF\"                 \n[10] \"No..Plasmids\"        \"kmer\"                \"Contigs\"            \n[13] \"N50\"                 \"longest.contig..bp.\" \"total.assembled.bp\" \n[16] \"contigs...1kb\"      \n\ncolnames(coli_genomes)\n\n [1] \"Strain\"              \"Biosample\"           \"Year.of.isolation\"  \n [4] \"Source\"              \"Phylogroup\"          \"Serotype\"           \n [7] \"Clonotype\"           \"Sequence.Type\"       \"VF\"                 \n[10] \"No..Plasmids\"        \"kmer\"                \"Contigs\"            \n[13] \"N50\"                 \"longest.contig..bp.\" \"total.assembled.bp\" \n[16] \"contigs...1kb\"      \n\nrownames(coli_genomes)\n\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\" \"14\" \"15\"\n[16] \"16\" \"17\" \"18\" \"19\" \"20\" \"21\" \"22\" \"23\" \"24\" \"25\"\n\nnames(coli_genomes[3]) &lt;- \"Year\"\nnames(coli_genomes)[3] &lt;- \"Year\"\ncolnames(coli_genomes[3]) &lt;- \"Year\"\n\nSome of the columns include ‘chr’ data that may be actually a categorical variable, so we can code them as factor. Using the expression as.factor() you can check whether the data would correspond to a text or a categorical variable.\n\ncoli_genomes$Source &lt;- as.factor(coli_genomes$Source)\ncoli_genomes$Phylogroup &lt;- as.factor(coli_genomes$Phylogroup)\n\nstr(coli_genomes)  #dataframe estructure updated\n\n'data.frame':   25 obs. of  16 variables:\n $ Strain             : chr  \"LREC237\" \"LREC239\" \"LREC240\" \"LREC241\" ...\n $ Biosample          : chr  \"SAMN14278613\" \"SAMN14278614\" \"SAMN14278615\" \"SAMN14278616\" ...\n $ Year               : int  NA 2010 2008 NA 2011 2007 2006 2006 2010 2013 ...\n $ Source             : Factor w/ 4 levels \"Avian \",\"Human\",..: 3 3 3 2 4 4 4 4 4 3 ...\n $ Phylogroup         : Factor w/ 4 levels \"A\",\"B1\",\"C\",\"D\": 4 3 2 1 1 1 1 1 3 4 ...\n $ Serotype           : chr  \"ONT:H28\" \"O153:H19\" \"O76:H30\" \"O78:H11\" ...\n $ Clonotype          : chr  \"CH23-331\" \"CH4-25\" \"CH29-38\" \"CH11-41\" ...\n $ Sequence.Type      : chr  \"ST524\" \"ST88\" \"ST156\" \"ST48\" ...\n $ VF                 : int  18 14 10 5 5 7 4 2 10 22 ...\n $ No..Plasmids       : int  3 3 2 3 9 3 7 7 1 4 ...\n $ kmer               : int  117 117 89 117 89 93 115 115 113 113 ...\n $ Contigs            : int  223 159 114 212 320 158 277 203 131 215 ...\n $ N50                : int  272287 323172 270767 112160 45936 106897 89185 94368 326769 248158 ...\n $ longest.contig..bp.: int  662555 760527 738861 285056 128053 369508 281444 280268 451887 504233 ...\n $ total.assembled.bp : int  5341632 5415613 4875343 5167401 4858138 4638334 5406295 4796593 5173794 5364777 ...\n $ contigs...1kb      : int  74 57 47 101 212 93 155 114 56 76 ...\n\n\nHow many levels are there in Source?? It is not uncommon to see some mistake in our data, usually made when the data were recorded, for example a space may have been inserted before a data value. By default this white space will be kept in the R environment, such that ‘Human’ will be recognized as a different value than ‘Human’. In order to avoid this type of error, we can use the strip.white argument.\n\nunique(coli_genomes$Source)\n\n[1] Human    Human    Porcine  Avian   \nLevels: Avian  Human Human  Porcine \n\ntable(coli_genomes$Source)\n\n\n  Avian     Human   Human  Porcine  \n       3        1       16        5 \n\ncoli_genomes &lt;- read.csv2(file = \"data/coli_genomes.csv\", strip.white = TRUE)\ncoli_genomes$Source &lt;- as.factor(coli_genomes$Source)\ncoli_genomes$Phylogroup &lt;- as.factor(coli_genomes$Phylogroup)\n\nunique(coli_genomes$Source)\n\n[1] Human   Porcine Avian  \nLevels: Avian Human Porcine\n\n\nWe can also rename some variables to use more easy names.\n\nnames(coli_genomes)  #see all variable names\n\n [1] \"Strain\"              \"Biosample\"           \"Year.of.isolation\"  \n [4] \"Source\"              \"Phylogroup\"          \"Serotype\"           \n [7] \"Clonotype\"           \"Sequence.Type\"       \"VF\"                 \n[10] \"No..Plasmids\"        \"kmer\"                \"Contigs\"            \n[13] \"N50\"                 \"longest.contig..bp.\" \"total.assembled.bp\" \n[16] \"contigs...1kb\"      \n\n# rename variables\nnames(coli_genomes)[3] &lt;- \"Year\"\nnames(coli_genomes)[10] &lt;- \"Plasmids\"\nnames(coli_genomes)[15] &lt;- \"Assembly_length\"\nnames(coli_genomes)[16] &lt;- \"contigs1kb\"\n# check\nnames(coli_genomes)\n\n [1] \"Strain\"              \"Biosample\"           \"Year\"               \n [4] \"Source\"              \"Phylogroup\"          \"Serotype\"           \n [7] \"Clonotype\"           \"Sequence.Type\"       \"VF\"                 \n[10] \"Plasmids\"            \"kmer\"                \"Contigs\"            \n[13] \"N50\"                 \"longest.contig..bp.\" \"Assembly_length\"    \n[16] \"contigs1kb\""
  },
  {
    "objectID": "r3.html#change-and-add-variables",
    "href": "r3.html#change-and-add-variables",
    "title": "R3: Read and write data in R",
    "section": "4.2 Change and add variables",
    "text": "4.2 Change and add variables\nWe are going to simplify our dataframe by dropping variables:\n\ncoli_genomes &lt;- coli_genomes[-c(9:11), ]\n# this can be also used to remove rows\ncoli_genomes[, -1]\n\n      Biosample Year  Source Phylogroup Serotype  Clonotype Sequence.Type VF\n1  SAMN14278613   NA   Human          D  ONT:H28   CH23-331         ST524 18\n2  SAMN14278614 2010   Human          C O153:H19     CH4-25          ST88 14\n3  SAMN14278615 2008   Human         B1  O76:H30    CH29-38         ST156 10\n4  SAMN14278616   NA   Human          A  O78:H11    CH11-41          ST48  5\n5  SAMN14278617 2011 Porcine          A  ONT:HNM     CH7-54         ST746  5\n6  SAMN14278618 2007 Porcine          A   O9:H37     CH7-31        ST3011  7\n7  SAMN14278619 2006 Porcine          A   O2:H32    CH11-23          ST10  4\n8  SAMN14278620 2006 Porcine          A  ONT:H45    C11-398       ST10888  2\n12 SAMN14278624 2013   Human          D O145:H28   CH23-331          ST32 22\n13 SAMN14278625 2013   Human          D O145:H28   CH23-331         ST137 22\n14 SAMN14278626 2013   Human          D O145:H28   CH23-331          ST32 20\n15 SAMN14278627 2013   Human          A  ONT:H37     C11-54          ST48  1\n16 SAMN14278628 2013   Avian          A  ONT:H19    CH94-23         ST347  2\n17 SAMN14278629 2011   Avian         B1 O142:H30     C41-35         ST359  9\n18 SAMN14278630 2005   Avian          C  O78:H19     CH4-27          ST88 11\n19 SAMN14278631 2012   Human          C   O8:H19     CH4-54          ST88 14\n20 SAMN14278632 2012   Human          C   O9:H19     CH4-27          ST88 14\n21 SAMN14278633 2012   Human          A    O9:H4     CH7-34          ST46  8\n22 SAMN14278634 2015   Human          C   O9:H19 CH4like-27       ST10890 13\n23 SAMN14278635 2012   Human          A  ONT:H33    CH11-54          ST10  2\n24 SAMN14278636 2016   Human          A  O98:H26    CH27-23        ST8233  2\n25 SAMN14278637 2012   Human         B1  O66:H10     CH4-32        ST1049  4\n   Plasmids kmer Contigs    N50 longest.contig..bp. Assembly_length contigs1kb\n1         3  117     223 272287              662555         5341632         74\n2         3  117     159 323172              760527         5415613         57\n3         2   89     114 270767              738861         4875343         47\n4         3  117     212 112160              285056         5167401        101\n5         9   89     320  45936              128053         4858138        212\n6         3   93     158 106897              369508         4638334         93\n7         7  115     277  89185              281444         5406295        155\n8         7  115     203  94368              280268         4796593        114\n12        1  115     376 200150              424527         5389075        131\n13        3  111     205 281589              617142         5340478         78\n14        1  113     206 182651              412836         5276782         95\n15        0  113     140 105396              272304         4507328         78\n16        0  117     134 110661              497785         4664768         77\n17        4  113     102 240847              460510         4992565         42\n18        4  113     108 405376             1190696         5196698         38\n19        2  113     108 281822             1140163         5252065         43\n20        4   91     224 140521              284241         5085107        110\n21        4   85     204  86565              300086         4915667        121\n22        3  113     171 326962              749412         5200701         77\n23        5  117     120 228491              576949         4881205         48\n24        4   89     114 187945              537848         4821342         53\n25        2  113      94 325747              822206         4839344         32\n\n\nWe know the ‘Assembly length’ and the number of ‘Contigs’, but we would like to represent the average contig length.\n\ncoli_genomes$average_contig &lt;- coli_genomes$Assembly_length/coli_genomes$Contigs"
  },
  {
    "objectID": "r3.html#dealing-with-nas",
    "href": "r3.html#dealing-with-nas",
    "title": "R3: Read and write data in R",
    "section": "4.3 Dealing with NAs",
    "text": "4.3 Dealing with NAs\nIt is very easy to calculate statistics of one variable. Imagine we want to know the average year of sample isolation.\n\nmean(coli_genomes$Year)\n\n[1] NA\n\n\nAs you may have guessed, the NA output means that there are some NA values and mean cannot be calculated. We can check that and omit the NAs.\n\n# check for NA values\nis.na(coli_genomes)\n\n   Strain Biosample  Year Source Phylogroup Serotype Clonotype Sequence.Type\n1   FALSE     FALSE  TRUE  FALSE      FALSE    FALSE     FALSE         FALSE\n2   FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n3   FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n4   FALSE     FALSE  TRUE  FALSE      FALSE    FALSE     FALSE         FALSE\n5   FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n6   FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n7   FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n8   FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n12  FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n13  FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n14  FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n15  FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n16  FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n17  FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n18  FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n19  FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n20  FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n21  FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n22  FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n23  FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n24  FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n25  FALSE     FALSE FALSE  FALSE      FALSE    FALSE     FALSE         FALSE\n      VF Plasmids  kmer Contigs   N50 longest.contig..bp. Assembly_length\n1  FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n2  FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n3  FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n4  FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n5  FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n6  FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n7  FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n8  FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n12 FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n13 FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n14 FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n15 FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n16 FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n17 FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n18 FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n19 FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n20 FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n21 FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n22 FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n23 FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n24 FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n25 FALSE    FALSE FALSE   FALSE FALSE               FALSE           FALSE\n   contigs1kb average_contig\n1       FALSE          FALSE\n2       FALSE          FALSE\n3       FALSE          FALSE\n4       FALSE          FALSE\n5       FALSE          FALSE\n6       FALSE          FALSE\n7       FALSE          FALSE\n8       FALSE          FALSE\n12      FALSE          FALSE\n13      FALSE          FALSE\n14      FALSE          FALSE\n15      FALSE          FALSE\n16      FALSE          FALSE\n17      FALSE          FALSE\n18      FALSE          FALSE\n19      FALSE          FALSE\n20      FALSE          FALSE\n21      FALSE          FALSE\n22      FALSE          FALSE\n23      FALSE          FALSE\n24      FALSE          FALSE\n25      FALSE          FALSE\n\n# alternative to check only NA-containing rows (a FALSE\n# output indicates an incomplete observation)\ncomplete.cases(coli_genomes)\n\n [1] FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n# na.rm=TRUE will omit the NAs for this function\nmean(coli_genomes$Year, na.rm = TRUE)\n\n[1] 2011\n\n\nWhat if we want to remove observations with an NA from the whole table?\n\n# create a new data.frame without NAs\ncoli_genomes2 &lt;- na.omit(coli_genomes)\n# can we now compute the mean without na.rm=T?\nmean(coli_genomes2$Year)\n\n[1] 2011\n\n\nIn fact, you can use na.omit() for any object, either an vector, data.frame or a list."
  },
  {
    "objectID": "r3.html#quick-exercise",
    "href": "r3.html#quick-exercise",
    "title": "R3: Read and write data in R",
    "section": "3.1 Quick exercise",
    "text": "3.1 Quick exercise\nLet’s see if you understood. Consider the following tree of directories.\n\nHow would you change de wd to the folder HPBBM2023/data and read the file small_matrix.csv?\nSelect the right answer\n\n setwd(“/data”) setwd(“/home/modesto/teaching/2023_2024/HPBBM2023/data”) setwd(“/Users/modesto/teaching/2023_2024/HPBBM2023/data”)\n\nYou can write any data object(s) as binary data file or as text files. Compare the different files saved in the code below.\n\nvector2 &lt;- c(3, 5:13)\nwrite(vector2, file = \"data/vector2.txt\")\nwrite.table(sm, \"data/sm.csv\")\nwrite.table(sm, \"data/sm2.csv\", row.names = FALSE, col.names = FALSE,\n    sep = \";\")\n\nsave(vector, vector2, file = \"data/vector2.Rdata\")\nsave.image(file = \"data/myEnvironment.RData\")\n\nData files in RData format can be open from the Environment tab or with the load() function\n\nsm_bis &lt;- load(\"data/vector2.Rdata\")\nsm_bis\n\n[1] \"vector\"  \"vector2\""
  },
  {
    "objectID": "r3.html#quick-exercise-i",
    "href": "r3.html#quick-exercise-i",
    "title": "R3: Read and write data in R",
    "section": "2.1 Quick exercise (I)",
    "text": "2.1 Quick exercise (I)\nLet’s see if you understood. Consider the following tree of directories.\n\nHow would you change de wd to the folder HPBBM2023/data? You also can try with your own computer and your directory tree.\nSelect the right answer\n\n setwd(“HPBBM2023/data”) setwd(“/home/modesto/teaching/2023_2024/HPBBM2023/data”) setwd(“/Users/modesto/teaching/2023_2024/HPBBM2023/data”)"
  },
  {
    "objectID": "r3.html#quick-exercise-ii",
    "href": "r3.html#quick-exercise-ii",
    "title": "R3: Read and write data in R",
    "section": "3.1 Quick exercise (II)",
    "text": "3.1 Quick exercise (II)\nWe are using the same directory tree. Your wd is HPBBM2022/data and you need to save a data.frame named table1 as table1.csv in the folder HPBBM2022/data using ; as separator. How would you do it without changing the working directory? Try it also with your own computer.\nSelect the right answer\n\n write.table(table1, “../../../HPBBM2023/data/table1.csv”, sep=“;”  write.table(table1, “../../HPBBM2023/data/table1.csv”, sep=“;”  write.table(table1, “../../../HPBBM2023/data/table1.csv”"
  },
  {
    "objectID": "r3.html#quick-exercise-iii",
    "href": "r3.html#quick-exercise-iii",
    "title": "R3: Read and write data in R",
    "section": "4.4 Quick exercise (III)",
    "text": "4.4 Quick exercise (III)\nNow, we need to save the current version of coli_genomes in the data folder, using the , as field separator.\nWhich of the following functions can you use to save the dataframe using , as field separator? write.tablawrite.csv2write.csvsave\nHow would you do it?\nSelect the right answer\n\n write.table(coli_genomes, “data/coli_genomes_renamed.csv”, sep=“,” ) write.csv2(coli_genomes, “data/coli_genomes_renamed.csv” ) write.csv(coli_genomes, “../coli_genomes_renamed.csv”)  write.csv(coli_genomes, “data/coli_genomes_renamed.csv”)\n\n\n\n\nFinally, do save the new dataset in your folder for future examples.\n\nwrite.csv(coli_genomes, \"data/coli_genomes_renamed.csv\", row.names = FALSE)"
  },
  {
    "objectID": "r3.html#footnotes",
    "href": "r3.html#footnotes",
    "title": "R3: Read and write data in R",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSince it is interactive we cannot run it when we render the source file into a web page. This can be prevented in markdown/quarto with the option `eval: false` in the chunk.↩︎"
  },
  {
    "objectID": "r4.html",
    "href": "r4.html",
    "title": "R4: Functions in R",
    "section": "",
    "text": "As you already know, R is a ‘GNU Software’ with a GPL license. As a a freely available language it has a great community of users from diverse background and interests. This community have developed a myriad of applications for R, called R Packages. Packages are the fundamental units of reproducible R code. They include reusable R functions, the documentation that describes how to use them, and sample data. The idea behind R packages is that the chances are that someone has already solved a problem that you’re working on, and you can benefit from their work by downloading their package.\nPackages can be installed from one of the public R repositories. In this course we will mainly use two R repos, CRAN and Bioconductor. The name CRAN stands for “The Comprehensive R Archive Network”, and it contains a huge variety of packages free to use. On the other hand, as we will see later on in the Lesson R9, Bioconductor is a repository of software devoted to bioinformatics or computational biology applications. As for June 2023, the CRAN package repository features 19,622 available packages whereas Bioconductor release 3.16 contains 2,183 packages.\nA full list of CRAN packages can be found here and a list by topic here.\n\n\nAs an example, we are going to install and use xlsx, a handy package to import/export tables in MS Excel format. You may also check related packages, such as readxl or pzfx.\n\n# install the package CRAN is the repository by default but it can be\n# optionally indicated\ninstall.packages(\"xlsx\", repos = \"https://cran.rstudio.com/\")\n\nYou must load the package before using it.\n\n# two ways of loading the packages 1 library(xlsx) 2 require(xlsx)\n\n# help help(xlsx) ??xlsx\n\n# trick to install package only if not installed if(!require(xlsx)){\n# install.packages('xlsx') library(xlsx) }\n\n# detach('package:xlsx', unload=TRUE) #unload the package\n\nOptionally, if you want to unload a package from memory, you can use detach(). This can be useful for long scripts.\nIn the above code we have used require() and library() functions to call for package loading. These are very similar functions that are often interchangeable. The main difference is that when you use require() and it cannot be executed, you will get a warning (see below for how to use warning), but not an error. Therefore, your code will always continue to execute if possible.\n\nlibrary(uam)\n\nError in library(uam): there is no package called 'uam'\n\nrequire(uam)\n\nLoading required package: uam\n\n\nWarning in library(package, lib.loc = lib.loc, character.only = TRUE,\nlogical.return = TRUE, : there is no package called 'uam'\n\n\nAs an example, we are going to read again the file coli_genomes_renamed.csv that we used in the previous lesson and export it ready for MS Excel.\n\n\n\n\n\n\nCross-lesson tip\n\n\n\nIf you have not worked with the R3 lesson yet, you can take a quick look at how we can open and save a table in R.\n\n\n\n# open it again\ncoli_genomes &lt;- read.csv(file = \"data/coli_genomes_renamed.csv\")\n# save library(xlsx) write.xlsx(coli_genomes,'data/coli_genomes.xlsx')\n\nMany packages in CRAN also contain a reference manual and some of them also a vignette. A vignette is practical guide to each package. You can see all the installed vignettes with browseVignettes() or just vignette() for the primary vignette. You can find a bunch of tutorials and tricks about how to use popular packages, but the vignette is an official and complete reference that is always helpful.\n\nbrowseVignettes(\"xlsx\")\n\nError in find.package(package, lib.loc): there is no package called 'xlsx'\n\nbrowseVignettes(\"seqinr\")\n\nError in find.package(package, lib.loc): there is no package called 'seqinr'\n\nbrowseVignettes(\"ggplot2\")\n\nstarting httpd help server ... done\n\n\nNote that in some cases, as in the package seqinr, there is no official vignette at CRAN. However, as R is an open access language, you will easily find information about any package or function in other websites, such as rdrr.io, rdocumentation.org or stackoverflow.com, among others.\n\n\n\nAs there are a lot of packages sometimes it takes some time to test different packages for the same analysis. Also, some packages become obsolete with a new R or RStudio version. Thus, is also a good habit to uninstall packages, with the function remove.package().\nSometimes, you can come into two different namesake functions from independent packages. Also, to reduce the memory load you may want to use a function without loading the package. In those cases, as in the examples below, there is a trick to call a specific function, the prefix package::. However, it should be noted that in some packages the syntax is complex and you need to call more than one function to actually use a major function.\n\n# package getwiki\ninstall.packages(\"getwiki\")\n\nInstalling package into '/home/luis/R/x86_64-pc-linux-gnu-library/4.3'\n(as 'lib' is unspecified)\n\nvignette(\"getwiki\")\nDNA &lt;- getwiki::search_wiki(\"DNA\")\nstr(DNA)\n\n'data.frame':   20 obs. of  2 variables:\n $ titles : chr  \"A-DNA\" \"Circular DNA\" \"DNA\" \"DNA extraction\" ...\n $ content: chr  \"A-DNA is one of the possible double helical structures which DNA can adopt. A-DNA is thought to be one of three\"| __truncated__ \"Circular DNA is DNA that forms a closed loop and has no ends.  Examples include:Plasmids, mobile genetic elemen\"| __truncated__ \"Deoxyribonucleic acid ( (listen); DNA) is a polymer composed of two polynucleotide chains that coil around each\"| __truncated__ \"The first isolation of deoxyribonucleic acid (DNA) was done in 1869 by Friedrich Miescher.  DNA extraction is t\"| __truncated__ ...\n\nDNA$titles\n\n [1] \"A-DNA\"                 \"Circular DNA\"          \"DNA\"                  \n [4] \"DNA extraction\"        \"DNA gyrase\"            \"DNA ligase\"           \n [7] \"DNA methylation\"       \"DNA on DNA\"            \"DNA polymerase\"       \n[10] \"DNA profiling\"         \"DNA repair\"            \"DNA replication\"      \n[13] \"DNA sequencing\"        \"DNA vaccine\"           \"DNA virus\"            \n[16] \"DNA²\"                  \"DNA–DNA hybridization\" \"DnaA\"                 \n[19] \"Mitochondrial DNA\"     \"Recombinant DNA\"      \n\n\n\n\n\nIn the four examples below, you will see that ggplot() function can be used if you call the package with the prefix ggplot::. However, to make a plot you need several functions and you need to either explicit the prefix for all the required functions (option #3) or load the package as in #4. Check the Lesson R7 for more info on ggplotting.\n\n# package ggplot2 1: no package load or calling with prefix\nggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) + geom_point()\n\nError in ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)): could not find function \"ggplot\"\n\n# 2: call the package with the prefix at the begining of the line\nggplot2::ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) + geom_point()\n\nError in aes(Petal.Length, Petal.Width, colour = Species): could not find function \"aes\"\n\n# 3: prefix in all functions\nggplot2::ggplot(iris, ggplot2::aes(Petal.Length, Petal.Width, colour = Species)) +\n    ggplot2::geom_point()\n\n\n\n# 4: load the package\nlibrary(ggplot2)\nggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) + geom_point()\n\n\n\n\nNote that in the example we have plotted some data from the dataset named iris. Did you load that data? No need. R has some built-in datasets that can be used as examples for plots or analysis. You can check all of them using the function data().\n\n\n\n\nInstall the package report and check its vignette and the info at the package site: https://easystats.github.io/report/\n\n\n\n\nSee an answer\n\ninstall.packages(\"report\")\n\nInstalling package into '/home/luis/R/x86_64-pc-linux-gnu-library/4.3'\n(as 'lib' is unspecified)\n\n\nalso installing the dependencies 'bayestestR', 'effectsize', 'insight', 'parameters', 'performance', 'datawizard'\n\nlibrary(report)\n\n# look for the vignette\nvignette(report)\n\nError in topic[1L]: object of type 'closure' is not subsettable\n\n# no vignette for report! Check also the CRAN site for further\n# documentation.\n\n\n\nAs we mentioned in the example with ggplot above, R has some built-in datasets that can be used as examples. Another of those datasets is called DNase and it contains data of several experiments of DNase treatment. Explore data and use the report package documentation and use it to test correlation between the DNase variables conc and density.\n\n\n\n\nSee an answer\n\nreport(DNase)\n\nThe data contains 176 observations of the following 3 variables:\n\n  - Run: 11 levels, namely 10 (n = 16, 9.09%), 11 (n = 16, 9.09%), 9 (n = 16,\n9.09%), 1 (n = 16, 9.09%), 4 (n = 16, 9.09%), 8 (n = 16, 9.09%), 5 (n = 16,\n9.09%), 7 (n = 16, 9.09%), 6 (n = 16, 9.09%), 2 (n = 16, 9.09%) and 3 (n = 16,\n9.09%)\n  - conc: n = 176, Mean = 3.11, SD = 4.06, Median = 1.17, MAD = 1.56, range:\n[0.05, 12.50], Skewness = 1.46, Kurtosis = 0.84, 0% missing\n  - density: n = 176, Mean = 0.72, SD = 0.60, Median = 0.53, MAD = 0.62, range:\n[0.01, 2.00], Skewness = 0.58, Kurtosis = -1.07, 0% missing\n\nreport(cor.test(DNase$conc, DNase$density))\n\nEffect sizes were labelled following Funder's (2019) recommendations.\n\nThe Pearson's product-moment correlation between DNase$conc and DNase$density\nis positive, statistically significant, and very large (r = 0.93, 95% CI [0.91,\n0.95], t(174) = 33.64, p &lt; .001)"
  },
  {
    "objectID": "r4.html#installing-and-use-r-packages",
    "href": "r4.html#installing-and-use-r-packages",
    "title": "R4: Functions in R",
    "section": "",
    "text": "As an example, we are going to install and use xlsx, a handy package to import/export tables in MS Excel format. You may also check related packages, such as readxl or pzfx.\n\n# install the package CRAN is the repository by default but it can be\n# optionally indicated\ninstall.packages(\"xlsx\", repos = \"https://cran.rstudio.com/\")\n\nYou must load the package before using it.\n\n# two ways of loading the packages 1 library(xlsx) 2 require(xlsx)\n\n# help help(xlsx) ??xlsx\n\n# trick to install package only if not installed if(!require(xlsx)){\n# install.packages('xlsx') library(xlsx) }\n\n# detach('package:xlsx', unload=TRUE) #unload the package\n\nOptionally, if you want to unload a package from memory, you can use detach(). This can be useful for long scripts.\nIn the above code we have used require() and library() functions to call for package loading. These are very similar functions that are often interchangeable. The main difference is that when you use require() and it cannot be executed, you will get a warning (see below for how to use warning), but not an error. Therefore, your code will always continue to execute if possible.\n\nlibrary(uam)\n\nError in library(uam): there is no package called 'uam'\n\nrequire(uam)\n\nLoading required package: uam\n\n\nWarning in library(package, lib.loc = lib.loc, character.only = TRUE,\nlogical.return = TRUE, : there is no package called 'uam'\n\n\nAs an example, we are going to read again the file coli_genomes_renamed.csv that we used in the previous lesson and export it ready for MS Excel.\n\n\n\n\n\n\nCross-lesson tip\n\n\n\nIf you have not worked with the R3 lesson yet, you can take a quick look at how we can open and save a table in R.\n\n\n\n# open it again\ncoli_genomes &lt;- read.csv(file = \"data/coli_genomes_renamed.csv\")\n# save library(xlsx) write.xlsx(coli_genomes,'data/coli_genomes.xlsx')\n\nMany packages in CRAN also contain a reference manual and some of them also a vignette. A vignette is practical guide to each package. You can see all the installed vignettes with browseVignettes() or just vignette() for the primary vignette. You can find a bunch of tutorials and tricks about how to use popular packages, but the vignette is an official and complete reference that is always helpful.\n\nbrowseVignettes(\"xlsx\")\n\nError in find.package(package, lib.loc): there is no package called 'xlsx'\n\nbrowseVignettes(\"seqinr\")\n\nError in find.package(package, lib.loc): there is no package called 'seqinr'\n\nbrowseVignettes(\"ggplot2\")\n\nstarting httpd help server ... done\n\n\nNote that in some cases, as in the package seqinr, there is no official vignette at CRAN. However, as R is an open access language, you will easily find information about any package or function in other websites, such as rdrr.io, rdocumentation.org or stackoverflow.com, among others."
  },
  {
    "objectID": "r4.html#why-how",
    "href": "r4.html#why-how",
    "title": "R4: Functions in R",
    "section": "2.1 Why? How?",
    "text": "2.1 Why? How?\nWe have discussed throughout the last lectures how R can help you if you to save time when you need to analyze and plot the data from your experiment. However, many times, particularly in Bioinformatics, you won’t have the data from one single experiment but from many of them.\nCreating you own function will be very useful for automation of repetitive analyses or to encapsulate a sequence of expressions that need to be executed numerous times, perhaps under slightly different conditions. Functions are also often written when code must be shared with others or the public.\nIn R, functions are also considered as objects. That means that (1) they can be nested, so you can define a function inside another function and (2) you can use functions as arguments to other functions. We will see very useful examples of this latter feature in Lesson R6, using custom functions as arguments for aggregate(), xtabs(), lapply() or sapply().\nThe overall scheme of an R function is the following:\nmy_function &lt;- function(argument1, argument2,...){\n  statements\n  return(object)\n  }"
  },
  {
    "objectID": "r4.html#my-first-simple-functions",
    "href": "r4.html#my-first-simple-functions",
    "title": "R4: Functions in R",
    "section": "2.2 My first simple functions",
    "text": "2.2 My first simple functions\nWe are going to learn with some examples from a good online tutorial. First, a quite simple function can simply help with calculations:\n\n# my first function\nmyFunction &lt;- function(x) {\n    f &lt;- x^2 * 4 + x/3\n    return(f)\n}\n# we try it\nmyFunction(4)\n\n[1] 65.33333\n\nmyFunction(0)\n\n[1] 0\n\nmyFunction(22)\n\n[1] 1943.333\n\nmyFunction(3)\n\n[1] 37\n\n\nWe can include conditions, loops… Another example can be a function to identify even/odd numbers:\n\n# A simple R function to check whether x is even or odd\nevenOdd &lt;- function(x) {\n    if (x%%2 == 0) {\n        return(\"even\")\n    } else {\n        return(\"odd\")\n    }\n}\n# test\nevenOdd(4)\n\n[1] \"even\"\n\nevenOdd(3)\n\n[1] \"odd\"\n\n# no need the curly braces!\nevenOdd2 &lt;- function(x) {\n    if (x%%2 == 0)\n        return(\"even\") else return(\"odd\")\n}\nevenOdd2(4)\n\n[1] \"even\"\n\nevenOdd2(3)\n\n[1] \"odd\"\n\nevenOdd2(7)\n\n[1] \"odd\"\n\nevenOdd2(8)\n\n[1] \"even\"\n\n\nIn the above example, we found out that curly braces can be omitted sometimes in if statements or loops (see https://www.learnbyexample.org/r-for-loop/#for-loop-without-curly-braces). This modification makes the code handier, but also riskier, use it carefully. Remember, a great power entails a great responsibility. The same applies to functions. Thus, sometimes when creating an R script, you want to create a small function and use it just once. That happens usually when you want to use your own functions to parse data within an apply family function (see Lesson R6). To deal with those situations, you can use the inline function. To create an inline function you have to use the function command with the argument x and then the expression of the function.\nExample:\n\n# inline functions\nf &lt;- function(x) x^2 * 4 + x/3\n\nf(4)\n\n[1] 65.33333\n\nf(0)\n\n[1] 0\n\nf(22)\n\n[1] 1943.333"
  },
  {
    "objectID": "r4.html#functions-with-multiple-arguments",
    "href": "r4.html#functions-with-multiple-arguments",
    "title": "R4: Functions in R",
    "section": "2.4 Functions with multiple arguments",
    "text": "2.4 Functions with multiple arguments\nNow, we will create a function in R Language that will take multiple inputs and gives us one output.\n\n# A simple R function to calculate area and perimeter of a rectangle\n\narea &lt;- function(length, width) {\n    area = length * width\n    # you may format the output\n    print(paste(\"The area of the rectangle is\", length, \"x\", width, \"=\", area,\n        \"cm²\"))\n}\n\narea(2, 3)  # call the function\n\n[1] \"The area of the rectangle is 2 x 3 = 6 cm²\"\n\n\nNotice that the output also can be a vector or a list:\n\n# Now we calculate area and perimeter of a rectangle\n\n\nRectangle &lt;- function(length, width) {\n    area = length * width\n    perimeter = 2 * (length + width)\n\n    # create an object called result which is a list of area and perimeter\n    result = list(Area = area, Perimeter = perimeter)\n    return(result)\n}\n\nRectangle(2, 3)\n\n$Area\n[1] 6\n\n$Perimeter\n[1] 10\n\n\nLike in any R function, you can call the arguments by position or by name. Thus, if add the names of the variables when calling the function you can switch the order of the arguments. Also, you can add some default values when you define the function.\n\n# A simple R code to demonstrate passing arguments to a function\n\nRectangle &lt;- function(length = 5, width = 4) {\n    area = length * width\n    return(area)\n}\n\n# Case 1:\nRectangle(2, 3)\n\n[1] 6\n\n# Case 2: If you do not want to follow any order, you can include the name\n# of the arguments\nRectangle(width = 8, length = 4)\n\n[1] 32\n\n# Case 3: default's values\nRectangle()\n\n[1] 20"
  },
  {
    "objectID": "r4.html#including-checkpoints",
    "href": "r4.html#including-checkpoints",
    "title": "R4: Functions in R",
    "section": "2.5 Including checkpoints",
    "text": "2.5 Including checkpoints\nNow we are going to try a longer code to solve the following example.\n\nHow many arguments should have this function? \nNow let’s see a possible way to do it:\n\n# we need to arguments\nprice_calculator &lt;- function(samples, category) {\n    categories &lt;- c(1, 1.15, 2)\n    names(categories) = c(\"normal\", \"priority\", \"urgent\")\n    if (samples &lt; 10) {\n        price &lt;- 19 * samples * which(names(categories) == category)\n    } else if (samples &lt; 50) {\n        price &lt;- 14 * samples * which(names(categories) == category)\n    } else if (samples &gt;= 50) {\n        price &lt;- 10 * samples * which(names(categories) == category)\n    }\n    paste(\"El precio es de\", price, \"euros.\")\n}\nprice_calculator(10, \"normal\")\n\n[1] \"El precio es de 140 euros.\"\n\nprice_calculator(10, \"urgent\")\n\n[1] \"El precio es de 420 euros.\"\n\nprice_calculator(10, \"urgnt\")\n\n[1] \"El precio es de  euros.\"\n\n\nIt seems to work, but it is not detecting wrong data input. How could we introduce checkpoints for the introduced arguments?\n\n# new version with checkpoints\nprice_calculator2 &lt;- function(samples, category = \"normal\" | \"priority\" | \"urgent\") {\n    category &lt;- switch(category, normal = 1, priority = 1.5, urgent = 2)\n    if (samples &lt; 10) {\n        price &lt;- 19 * samples * category\n    } else if (samples &lt; 50) {\n        price &lt;- 14 * samples * category\n    } else if (samples &gt;= 50) {\n        price &lt;- 10 * samples * category\n    }\n    ifelse(length(price) &gt; 0, return(price), stop(\"Prioridad incorecta. No se ha podido calcular el precio\"))\n}\nprice_calculator2(10, \"normal\")\n\n[1] 140\n\nprice_calculator2(10, \"urgent\")\n\n[1] 280\n\nprice_calculator2(10, \"urgnt\")\n\nError in ifelse(length(price) &gt; 0, return(price), stop(\"Prioridad incorecta. No se ha podido calcular el precio\")): Prioridad incorecta. No se ha podido calcular el precio\n\nprice_calculator2(5.3, \"normal\")\n\n[1] 100.7\n\n# WTF?\n\nWe just noticed that the function calculated the price for 5.3 samples, which is nonsense. We should then introduce a new checkpoint for the format of the introduced value for the variable samples.\n\n# alternative with checkpoint for number of samples\nprice_calculator3 &lt;- function(samples, category = \"normal\" | \"priority\" | \"urgent\") {\n    category &lt;- switch(category, normal = 1, priority = 1.5, urgent = 2)\n    if (abs(floor(samples)) != samples) {\n        # check that number of samples is an integer number\n        stop(\"Número de muestras incorrecto\")\n    }\n    if (samples &lt; 10) {\n        price &lt;- 19 * samples * category\n    } else if (samples &lt; 50) {\n        price &lt;- 14 * samples * category\n    } else if (samples &gt;= 50) {\n        price &lt;- 10 * samples * category\n    }\n    ifelse(length(price) &gt; 0, return(price), stop(\"Prioridad incorecta. No se ha podido calcular el precio\"))\n}\n\n# test again\nprice_calculator3(50, \"urgente\")\n\nError in ifelse(length(price) &gt; 0, return(price), stop(\"Prioridad incorecta. No se ha podido calcular el precio\")): Prioridad incorecta. No se ha podido calcular el precio\n\nprice_calculator3(50, \"urgent\")\n\n[1] 1000\n\nprice_calculator3(-5, \"normal\")\n\nError in price_calculator3(-5, \"normal\"): Número de muestras incorrecto\n\nprice_calculator3(5.2, \"normal\")\n\nError in price_calculator3(5.2, \"normal\"): Número de muestras incorrecto"
  },
  {
    "objectID": "r4.html#exercise",
    "href": "r4.html#exercise",
    "title": "R4: Functions in R",
    "section": "2.5 Exercise",
    "text": "2.5 Exercise\nWhen creating functions, you can include any R functionality, including reading and parsing external data files. Let’s do a short exercise, within the context of molecular biology.\nCan you write a function that convert R into a molecular biology dogma interpreter. You can use the table genetic_code.csv, located in the data folder that contains the conversion between all the nucleic acid sequence codons and its encoded amino acid in IUPAC one letter code. Try it with some examples, including right and wrong codons, like “ATG”, “TAA”, “CAT”, or “AXG”.\n\n\n\nSee an answer\n\n# the molecular biology dogma with R\n\ncodon2aa &lt;- function(inputCodon) {\n    code &lt;- read.csv2(\"data/genetic_code.csv\", stringsAsFactors = FALSE)\n    aa &lt;- code$AA[code$Codon == inputCodon]\n    return(aa)\n}\n# now let's try it\ncodon2aa(\"ATG\")\ncodon2aa(\"TAA\")\ncodon2aa(\"CAT\")\ncodon2aa(\"AXG\")\n\n\nCan you also check the value of the variable aa ?\n\n#'aa'??\nprint(aa)\n\nError in eval(expr, envir, enclos): object 'aa' not found\n\n\nWhat just happened? There are a few things worth to comment here:\n\nIf the function cannot find the right value to return, the output is empty: character(0)\nThe variable aa seems nonexistent! Variables defined in a function are only local variables and cannot be called outside the function.\n\nHowever, proteins are made up of more than one amino acid, so it’d be great if the input could be a vector of several codons instead a single codon.\nCan you add checkpoints and decide how to handle errors?\n\n\n\nSee an answer\n\n# version 2\n\ncodon2aa_2 &lt;- function(codons) {\n    aa &lt;- c()\n    code &lt;- read.csv2(\"data/genetic_code.csv\", stringsAsFactors = FALSE)\n    for (i in 1:length(codons)) {\n        # loop over all the elements of the vector 'codons'\n        stopifnot(`Uno o más de los codones no es correcto. No se ha podido traducir ;)` = codons[i] %in%\n            code$Codon)  #check for correct values\n        aa[i] &lt;- code$AA[code$Codon == codons[i]]\n    }\n    return(aa)\n}\n\n# let's try it\ncodon2aa_2(c(\"ATG\", \"TGA\"))\ncodon2aa_2(c(\"ARG\", \"TGA\"))\ncodon2aa_2(c(\"ATG\", \"CAT\", \"CAT\", \"AAA\", \"TAA\"))\n\n\nIn this second example, aa is not a numeric variable (=vector of 1 element), but a “normal vector”, so we need to define it before using in the loop. Also, we have used the function stopifnot() to check for the codons. This function is a shortcut for a standard if{} or ifelse{} to check the codons and a stop if they are not found."
  },
  {
    "objectID": "r4.html#more-exercises",
    "href": "r4.html#more-exercises",
    "title": "R4: Functions in R",
    "section": "4.1 More exercises…",
    "text": "4.1 More exercises…\nhttps://www.r-bloggers.com/2016/02/functions-exercises/\nhttp://mathcenter.oxford.emory.edu/site/math117/probSetRFunctions/"
  },
  {
    "objectID": "r4.html#quick-exercise-i",
    "href": "r4.html#quick-exercise-i",
    "title": "R4: Functions in R",
    "section": "",
    "text": "Install the package report and check its vignette and the info at the package site: https://easystats.github.io/report/\n\n\n\n\nSee an answer\n\ninstall.packages(\"report\")\n\nInstalling package into '/home/luis/R/x86_64-pc-linux-gnu-library/4.3'\n(as 'lib' is unspecified)\n\n\nalso installing the dependencies 'bayestestR', 'effectsize', 'insight', 'parameters', 'performance', 'datawizard'\n\nlibrary(report)\n\n# look for the vignette\nvignette(report)\n\nError in topic[1L]: object of type 'closure' is not subsettable\n\n# no vignette for report! Check also the CRAN site for further\n# documentation.\n\n\n\nAs we mentioned in the example with ggplot above, R has some built-in datasets that can be used as examples. Another of those datasets is called DNase and it contains data of several experiments of DNase treatment. Explore data and use the report package documentation and use it to test correlation between the DNase variables conc and density.\n\n\n\n\nSee an answer\n\nreport(DNase)\n\nThe data contains 176 observations of the following 3 variables:\n\n  - Run: 11 levels, namely 10 (n = 16, 9.09%), 11 (n = 16, 9.09%), 9 (n = 16,\n9.09%), 1 (n = 16, 9.09%), 4 (n = 16, 9.09%), 8 (n = 16, 9.09%), 5 (n = 16,\n9.09%), 7 (n = 16, 9.09%), 6 (n = 16, 9.09%), 2 (n = 16, 9.09%) and 3 (n = 16,\n9.09%)\n  - conc: n = 176, Mean = 3.11, SD = 4.06, Median = 1.17, MAD = 1.56, range:\n[0.05, 12.50], Skewness = 1.46, Kurtosis = 0.84, 0% missing\n  - density: n = 176, Mean = 0.72, SD = 0.60, Median = 0.53, MAD = 0.62, range:\n[0.01, 2.00], Skewness = 0.58, Kurtosis = -1.07, 0% missing\n\nreport(cor.test(DNase$conc, DNase$density))\n\nEffect sizes were labelled following Funder's (2019) recommendations.\n\nThe Pearson's product-moment correlation between DNase$conc and DNase$density\nis positive, statistically significant, and very large (r = 0.93, 95% CI [0.91,\n0.95], t(174) = 33.64, p &lt; .001)"
  },
  {
    "objectID": "r4.html#quick-exercise-ii",
    "href": "r4.html#quick-exercise-ii",
    "title": "R4: Functions in R",
    "section": "2.3 Quick exercise (II)",
    "text": "2.3 Quick exercise (II)\nWrite an inline function that transforms concentrations units: molar (M) into micromolar (µM). Test it with your own R session.\nSelect the right answer\n\n f &lt;- function(x) 1000 f &lt;- function(x) x * 1000 f &lt;- function(x) x 1000"
  },
  {
    "objectID": "r4.html#quick-exercise-iii",
    "href": "r4.html#quick-exercise-iii",
    "title": "R4: Functions in R",
    "section": "2.6 Quick exercise (III)",
    "text": "2.6 Quick exercise (III)\nWhen creating functions, you can include any R functionality, including reading and parsing external data files. Let’s do a short exercise, within the context of molecular biology.\nCan you write a function that convert R into a molecular biology dogma interpreter?\nYou can use the table genetic_code.csv, located in the data folder that contains the conversion between all the nucleic acid sequence codons and its encoded amino acid in IUPAC one letter code.\nTry it with some examples, including right and wrong codons, like “ATG”, “TAA”, “CAT”, or “AXG”.\n\n\n\nAnswer\n\n# the molecular biology dogma with R\n\ncodon2aa &lt;- function(inputCodon) {\n    code &lt;- read.csv2(\"data/genetic_code.csv\", stringsAsFactors = FALSE)\n    aa &lt;- code$AA[code$Codon == inputCodon]\n    return(aa)\n}\n# now let's try it\ncodon2aa(\"ATG\")\n\n[1] \"M\"\n\ncodon2aa(\"TAA\")\n\n[1] \"*\"\n\ncodon2aa(\"CAT\")\n\n[1] \"H\"\n\ncodon2aa(\"AXG\")\n\ncharacter(0)\n\n\n\nCan you also check the value of the variable aa ?\n\n#'aa'??\nprint(aa)\n\nError in eval(expr, envir, enclos): object 'aa' not found\n\n\nWhat just happened? There are a few things worth to comment here:\n\nIf the function cannot find the right value to return, the output is empty: character(0)\nThe variable aa seems nonexistent! Variables defined in a function are only local variables and cannot be called outside the function.\n\nHowever, proteins are made up of more than one amino acid, so it’d be great if the input could be a vector of several codons instead a single codon.\nCan you add checkpoints and decide how to handle errors?\n\n\n\nSee an answer\n\n# version 2\n\ncodon2aa_2 &lt;- function(codons) {\n    aa &lt;- c()\n    code &lt;- read.csv2(\"data/genetic_code.csv\", stringsAsFactors = FALSE)\n    for (i in 1:length(codons)) {\n        # loop over all the elements of the vector 'codons'\n        stopifnot(`Uno o más de los codones no es correcto. No se ha podido traducir ;)` = codons[i] %in%\n            code$Codon)  #check for correct values\n        aa[i] &lt;- code$AA[code$Codon == codons[i]]\n    }\n    return(aa)\n}\n\n# let's try it\ncodon2aa_2(c(\"ATG\", \"TGA\"))\n\n[1] \"M\" \"*\"\n\ncodon2aa_2(c(\"ARG\", \"TGA\"))\n\nError in codon2aa_2(c(\"ARG\", \"TGA\")): Uno o más de los codones no es correcto. No se ha podido traducir ;)\n\ncodon2aa_2(c(\"ATG\", \"CAT\", \"CAT\", \"AAA\", \"TAA\"))\n\n[1] \"M\" \"H\" \"H\" \"K\" \"*\"\n\n\n\nIn this second example, aa is not a numeric variable (=vector of 1 element), but a “normal vector”, so we need to define it before using in the loop. Also, we have used the function stopifnot() to check for the codons. This function is a shortcut for a standard if{} or ifelse{} to check the codons and a stop if they are not found."
  },
  {
    "objectID": "r4.html#quick-exercise-iv",
    "href": "r4.html#quick-exercise-iv",
    "title": "R4: Functions in R",
    "section": "2.7 Quick exercise (IV)",
    "text": "2.7 Quick exercise (IV)\nWrite a function that calculate your approximate age in months.\n\n\n\nHint\n\n`?`(as.Date)\n`?`(difftime)\n\n# See some examples:\n# https://www.geeksforgeeks.org/calculate-time-difference-between-dates-in-r-programming-difftime-function/\n\n\n\n\n\nAnswer 1\n\n# quickest way I found\nage &lt;- function(x) {\n    if (!is.na(as.Date(as.character(x), format = \"%Y-%m-%d\"))) {\n        age &lt;- as.numeric(Sys.Date() - as.Date(x, format = \"%Y-%m-%d\"))  #result in days\n        print(paste(\"You are about\", round(age/30, 1), \"months old\"))\n    } else {\n        stop(\"The input date must be quoted and in format YYYY-MM-DD\")\n    }\n}\n# test\nage(18)\n\nError in age(18): The input date must be quoted and in format YYYY-MM-DD\n\nage(\"2004-11-17\")\n\n[1] \"You are about 227.1 months old\"\n\n\n\n\n\n\nAnswer 2\n\n# alternative using interactive input & difftime()\ndf &lt;- function(x) {\n    if (missing(x)) {\n        # check for input date if missing, we can ask the user for input\n        x &lt;- readline(prompt = \"Introduce your birthdate in the format YYYY-MM-DD: \")\n    }\n    if (!is.na(as.Date(as.character(x), format = \"%Y-%m-%d\"))) {\n        df &lt;- difftime(Sys.Date(), as.Date(x, format = \"%Y-%m-%d\"))\n        print(paste0(\"If you were born on \", x, \", you are about \", round(as.numeric(df)/30,\n            1), \" months old.\"))\n    } else {\n        stop(\"The input date must be in format YYYY-MM-DD\")\n    }\n}\ndf(\"2004-11-17\")\n\n[1] \"If you were born on 2004-11-17, you are about 227.1 months old.\"\n\ndf(18)\n\nError in df(18): The input date must be in format YYYY-MM-DD\n\ndf()\n\nIntroduce your birthdate in the format YYYY-MM-DD: \n\n\nError in df(): The input date must be in format YYYY-MM-DD"
  },
  {
    "objectID": "r4.html#too-many-packages",
    "href": "r4.html#too-many-packages",
    "title": "R4: Functions in R",
    "section": "",
    "text": "As there are a lot of packages sometimes it takes some time to test different packages for the same analysis. Also, some packages become obsolete with a new R or RStudio version. Thus, is also a good habit to uninstall packages, with the function remove.package().\nSometimes, you can come into two different namesake functions from independent packages. Also, to reduce the memory load you may want to use a function without loading the package. In those cases, as in the examples below, there is a trick to call a specific function, the prefix package::. However, it should be noted that in some packages the syntax is complex and you need to call more than one function to actually use a major function.\n\n# package getwiki\ninstall.packages(\"getwiki\")\n\nInstalling package into '/home/luis/R/x86_64-pc-linux-gnu-library/4.3'\n(as 'lib' is unspecified)\n\nvignette(\"getwiki\")\nDNA &lt;- getwiki::search_wiki(\"DNA\")\nstr(DNA)\n\n'data.frame':   20 obs. of  2 variables:\n $ titles : chr  \"A-DNA\" \"Circular DNA\" \"DNA\" \"DNA extraction\" ...\n $ content: chr  \"A-DNA is one of the possible double helical structures which DNA can adopt. A-DNA is thought to be one of three\"| __truncated__ \"Circular DNA is DNA that forms a closed loop and has no ends.  Examples include:Plasmids, mobile genetic elemen\"| __truncated__ \"Deoxyribonucleic acid ( (listen); DNA) is a polymer composed of two polynucleotide chains that coil around each\"| __truncated__ \"The first isolation of deoxyribonucleic acid (DNA) was done in 1869 by Friedrich Miescher.  DNA extraction is t\"| __truncated__ ...\n\nDNA$titles\n\n [1] \"A-DNA\"                 \"Circular DNA\"          \"DNA\"                  \n [4] \"DNA extraction\"        \"DNA gyrase\"            \"DNA ligase\"           \n [7] \"DNA methylation\"       \"DNA on DNA\"            \"DNA polymerase\"       \n[10] \"DNA profiling\"         \"DNA repair\"            \"DNA replication\"      \n[13] \"DNA sequencing\"        \"DNA vaccine\"           \"DNA virus\"            \n[16] \"DNA²\"                  \"DNA–DNA hybridization\" \"DnaA\"                 \n[19] \"Mitochondrial DNA\"     \"Recombinant DNA\"      \n\n\n\n\n\nIn the four examples below, you will see that ggplot() function can be used if you call the package with the prefix ggplot::. However, to make a plot you need several functions and you need to either explicit the prefix for all the required functions (option #3) or load the package as in #4. Check the Lesson R7 for more info on ggplotting.\n\n# package ggplot2 1: no package load or calling with prefix\nggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) + geom_point()\n\nError in ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)): could not find function \"ggplot\"\n\n# 2: call the package with the prefix at the begining of the line\nggplot2::ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) + geom_point()\n\nError in aes(Petal.Length, Petal.Width, colour = Species): could not find function \"aes\"\n\n# 3: prefix in all functions\nggplot2::ggplot(iris, ggplot2::aes(Petal.Length, Petal.Width, colour = Species)) +\n    ggplot2::geom_point()\n\n\n\n# 4: load the package\nlibrary(ggplot2)\nggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) + geom_point()\n\n\n\n\nNote that in the example we have plotted some data from the dataset named iris. Did you load that data? No need. R has some built-in datasets that can be used as examples for plots or analysis. You can check all of them using the function data()."
  },
  {
    "objectID": "r3.html#open-and-explore-a-dataframe",
    "href": "r3.html#open-and-explore-a-dataframe",
    "title": "R3: Read and write data in R",
    "section": "4.1 Open and explore a dataframe",
    "text": "4.1 Open and explore a dataframe\nAs you can see in the R help, the function read.table() has several default options as FALSE, like header=FALSE. When you have a spreadsheet export file, i.e. having a table where the fields are divided by commas in place of spaces, you can use read.csv() in place of read.table(). For Spaniards, there is also read.csv2(), which uses a comma for the decimal point and a semicolon for the separator. The latter functions are wrappers of read.table() with custom default options. Likewise, there are write.csv() and write.csv2(), which are wrappers of write.table(). Look carefully at the following examples of different ways to open a table (with some common mistakes) and explore them quickly.\n\n# Note differences between read.table(), read.csv() and\n# read.csv2()\ncoli_genomes &lt;- read.table(file = \"data/coli_genomes.csv\")\n\nError in scan(file = file, what = what, sep = sep, quote = quote, dec = dec, : line 2 did not have 11 elements\n\nhead(coli_genomes)\n\nError in eval(expr, envir, enclos): object 'coli_genomes' not found\n\ncoli_genomes &lt;- read.table(file = \"data/coli_genomes.csv\", sep = \";\",\n    dec = \".\", header = TRUE)\nhead(coli_genomes)\n\n   Strain    Biosample Year.of.isolation   Source Phylogroup Serotype Clonotype\n1 LREC237 SAMN14278613                NA   Human           D  ONT:H28  CH23-331\n2 LREC239 SAMN14278614              2010   Human           C O153:H19    CH4-25\n3 LREC240 SAMN14278615              2008   Human          B1  O76:H30   CH29-38\n4 LREC241 SAMN14278616                NA    Human          A  O78:H11   CH11-41\n5 LREC242 SAMN14278617              2011 Porcine           A  ONT:HNM    CH7-54\n6 LREC243 SAMN14278618              2007 Porcine           A   O9:H37    CH7-31\n  Sequence.Type VF No..Plasmids kmer Contigs    N50 longest.contig..bp.\n1         ST524 18            3  117     223 272287              662555\n2          ST88 14            3  117     159 323172              760527\n3         ST156 10            2   89     114 270767              738861\n4          ST48  5            3  117     212 112160              285056\n5         ST746  5            9   89     320  45936              128053\n6        ST3011  7            3   93     158 106897              369508\n  total.assembled.bp contigs...1kb\n1            5341632            74\n2            5415613            57\n3            4875343            47\n4            5167401           101\n5            4858138           212\n6            4638334            93\n\ncoli_genomes &lt;- read.csv(file = \"data/coli_genomes.csv\")\nhead(coli_genomes)\n\n  Strain.Biosample.Year.of.isolation.Source.Phylogroup.Serotype.Clonotype.Sequence.Type.VF.No..Plasmids.kmer.Contigs.N50.longest.contig..bp..total.assembled.bp.contigs...1kb\n1                                                                               LREC237;SAMN14278613;NA;Human ;D;ONT:H28;CH23-331;ST524;18;3;117;223;272287;662555;5341632;74\n2                                                                               LREC239;SAMN14278614;2010;Human ;C;O153:H19;CH4-25;ST88;14;3;117;159;323172;760527;5415613;57\n3                                                                              LREC240;SAMN14278615;2008;Human ;B1;O76:H30;CH29-38;ST156;10;2;89;114;270767;738861;4875343;47\n4                                                                                  LREC241;SAMN14278616;NA;Human;A;O78:H11;CH11-41;ST48;5;3;117;212;112160;285056;5167401;101\n5                                                                               LREC242;SAMN14278617;2011;Porcine ;A;ONT:HNM;CH7-54;ST746;5;9;89;320;45936;128053;4858138;212\n6                                                                               LREC243;SAMN14278618;2007;Porcine ;A;O9:H37;CH7-31;ST3011;7;3;93;158;106897;369508;4638334;93\n\ncoli_genomes &lt;- read.csv(file = \"data/coli_genomes.csv\", sep = \";\")\nhead(coli_genomes)\n\n   Strain    Biosample Year.of.isolation   Source Phylogroup Serotype Clonotype\n1 LREC237 SAMN14278613                NA   Human           D  ONT:H28  CH23-331\n2 LREC239 SAMN14278614              2010   Human           C O153:H19    CH4-25\n3 LREC240 SAMN14278615              2008   Human          B1  O76:H30   CH29-38\n4 LREC241 SAMN14278616                NA    Human          A  O78:H11   CH11-41\n5 LREC242 SAMN14278617              2011 Porcine           A  ONT:HNM    CH7-54\n6 LREC243 SAMN14278618              2007 Porcine           A   O9:H37    CH7-31\n  Sequence.Type VF No..Plasmids kmer Contigs    N50 longest.contig..bp.\n1         ST524 18            3  117     223 272287              662555\n2          ST88 14            3  117     159 323172              760527\n3         ST156 10            2   89     114 270767              738861\n4          ST48  5            3  117     212 112160              285056\n5         ST746  5            9   89     320  45936              128053\n6        ST3011  7            3   93     158 106897              369508\n  total.assembled.bp contigs...1kb\n1            5341632            74\n2            5415613            57\n3            4875343            47\n4            5167401           101\n5            4858138           212\n6            4638334            93\n\ncoli_genomes &lt;- read.csv2(file = \"data/coli_genomes.csv\")\nhead(coli_genomes)\n\n   Strain    Biosample Year.of.isolation   Source Phylogroup Serotype Clonotype\n1 LREC237 SAMN14278613                NA   Human           D  ONT:H28  CH23-331\n2 LREC239 SAMN14278614              2010   Human           C O153:H19    CH4-25\n3 LREC240 SAMN14278615              2008   Human          B1  O76:H30   CH29-38\n4 LREC241 SAMN14278616                NA    Human          A  O78:H11   CH11-41\n5 LREC242 SAMN14278617              2011 Porcine           A  ONT:HNM    CH7-54\n6 LREC243 SAMN14278618              2007 Porcine           A   O9:H37    CH7-31\n  Sequence.Type VF No..Plasmids kmer Contigs    N50 longest.contig..bp.\n1         ST524 18            3  117     223 272287              662555\n2          ST88 14            3  117     159 323172              760527\n3         ST156 10            2   89     114 270767              738861\n4          ST48  5            3  117     212 112160              285056\n5         ST746  5            9   89     320  45936              128053\n6        ST3011  7            3   93     158 106897              369508\n  total.assembled.bp contigs...1kb\n1            5341632            74\n2            5415613            57\n3            4875343            47\n4            5167401           101\n5            4858138           212\n6            4638334            93\n\n# read some data\nhead(coli_genomes)\n\n   Strain    Biosample Year.of.isolation   Source Phylogroup Serotype Clonotype\n1 LREC237 SAMN14278613                NA   Human           D  ONT:H28  CH23-331\n2 LREC239 SAMN14278614              2010   Human           C O153:H19    CH4-25\n3 LREC240 SAMN14278615              2008   Human          B1  O76:H30   CH29-38\n4 LREC241 SAMN14278616                NA    Human          A  O78:H11   CH11-41\n5 LREC242 SAMN14278617              2011 Porcine           A  ONT:HNM    CH7-54\n6 LREC243 SAMN14278618              2007 Porcine           A   O9:H37    CH7-31\n  Sequence.Type VF No..Plasmids kmer Contigs    N50 longest.contig..bp.\n1         ST524 18            3  117     223 272287              662555\n2          ST88 14            3  117     159 323172              760527\n3         ST156 10            2   89     114 270767              738861\n4          ST48  5            3  117     212 112160              285056\n5         ST746  5            9   89     320  45936              128053\n6        ST3011  7            3   93     158 106897              369508\n  total.assembled.bp contigs...1kb\n1            5341632            74\n2            5415613            57\n3            4875343            47\n4            5167401           101\n5            4858138           212\n6            4638334            93\n\ntail(coli_genomes, n = 2)\n\n    Strain    Biosample Year.of.isolation Source Phylogroup Serotype Clonotype\n24 LREC261 SAMN14278636              2016 Human           A  O98:H26   CH27-23\n25 LREC262 SAMN14278637              2012 Human          B1  O66:H10    CH4-32\n   Sequence.Type VF No..Plasmids kmer Contigs    N50 longest.contig..bp.\n24        ST8233  2            4   89     114 187945              537848\n25        ST1049  4            2  113      94 325747              822206\n   total.assembled.bp contigs...1kb\n24            4821342            53\n25            4839344            32\n\ncoli_genomes[1, ]\n\n   Strain    Biosample Year.of.isolation Source Phylogroup Serotype Clonotype\n1 LREC237 SAMN14278613                NA Human           D  ONT:H28  CH23-331\n  Sequence.Type VF No..Plasmids kmer Contigs    N50 longest.contig..bp.\n1         ST524 18            3  117     223 272287              662555\n  total.assembled.bp contigs...1kb\n1            5341632            74\n\ncoli_genomes[, 1]\n\n [1] \"LREC237\" \"LREC239\" \"LREC240\" \"LREC241\" \"LREC242\" \"LREC243\" \"LREC244\"\n [8] \"LREC245\" \"LREC246\" \"LREC247\" \"LREC248\" \"LREC249\" \"LREC250\" \"LREC251\"\n[15] \"LREC252\" \"LREC253\" \"LREC254\" \"LREC255\" \"LREC256\" \"LREC257\" \"LREC258\"\n[22] \"LREC259\" \"LREC260\" \"LREC261\" \"LREC262\"\n\ncoli_genomes[1:6, 2:4]\n\n     Biosample Year.of.isolation   Source\n1 SAMN14278613                NA   Human \n2 SAMN14278614              2010   Human \n3 SAMN14278615              2008   Human \n4 SAMN14278616                NA    Human\n5 SAMN14278617              2011 Porcine \n6 SAMN14278618              2007 Porcine \n\n# explore the dataframe structure\ndim(coli_genomes)\n\n[1] 25 16\n\nlength(coli_genomes)\n\n[1] 16\n\nncol(coli_genomes)\n\n[1] 16\n\nnrow(coli_genomes)\n\n[1] 25\n\n# dataframe estructure in one line\nstr(coli_genomes)\n\n'data.frame':   25 obs. of  16 variables:\n $ Strain             : chr  \"LREC237\" \"LREC239\" \"LREC240\" \"LREC241\" ...\n $ Biosample          : chr  \"SAMN14278613\" \"SAMN14278614\" \"SAMN14278615\" \"SAMN14278616\" ...\n $ Year.of.isolation  : int  NA 2010 2008 NA 2011 2007 2006 2006 2010 2013 ...\n $ Source             : chr  \"Human \" \"Human \" \"Human \" \"Human\" ...\n $ Phylogroup         : chr  \"D\" \"C\" \"B1\" \"A\" ...\n $ Serotype           : chr  \"ONT:H28\" \"O153:H19\" \"O76:H30\" \"O78:H11\" ...\n $ Clonotype          : chr  \"CH23-331\" \"CH4-25\" \"CH29-38\" \"CH11-41\" ...\n $ Sequence.Type      : chr  \"ST524\" \"ST88\" \"ST156\" \"ST48\" ...\n $ VF                 : int  18 14 10 5 5 7 4 2 10 22 ...\n $ No..Plasmids       : int  3 3 2 3 9 3 7 7 1 4 ...\n $ kmer               : int  117 117 89 117 89 93 115 115 113 113 ...\n $ Contigs            : int  223 159 114 212 320 158 277 203 131 215 ...\n $ N50                : int  272287 323172 270767 112160 45936 106897 89185 94368 326769 248158 ...\n $ longest.contig..bp.: int  662555 760527 738861 285056 128053 369508 281444 280268 451887 504233 ...\n $ total.assembled.bp : int  5341632 5415613 4875343 5167401 4858138 4638334 5406295 4796593 5173794 5364777 ...\n $ contigs...1kb      : int  74 57 47 101 212 93 155 114 56 76 ...\n\n# type of data in each variable\ntypeof(coli_genomes$Strain)\n\n[1] \"character\"\n\ntypeof(coli_genomes[, 2])\n\n[1] \"character\"\n\ntypeof(coli_genomes[, 9])\n\n[1] \"integer\"\n\n# col and row names\nnames(coli_genomes)\n\n [1] \"Strain\"              \"Biosample\"           \"Year.of.isolation\"  \n [4] \"Source\"              \"Phylogroup\"          \"Serotype\"           \n [7] \"Clonotype\"           \"Sequence.Type\"       \"VF\"                 \n[10] \"No..Plasmids\"        \"kmer\"                \"Contigs\"            \n[13] \"N50\"                 \"longest.contig..bp.\" \"total.assembled.bp\" \n[16] \"contigs...1kb\"      \n\ncolnames(coli_genomes)\n\n [1] \"Strain\"              \"Biosample\"           \"Year.of.isolation\"  \n [4] \"Source\"              \"Phylogroup\"          \"Serotype\"           \n [7] \"Clonotype\"           \"Sequence.Type\"       \"VF\"                 \n[10] \"No..Plasmids\"        \"kmer\"                \"Contigs\"            \n[13] \"N50\"                 \"longest.contig..bp.\" \"total.assembled.bp\" \n[16] \"contigs...1kb\"      \n\nrownames(coli_genomes)\n\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\" \"14\" \"15\"\n[16] \"16\" \"17\" \"18\" \"19\" \"20\" \"21\" \"22\" \"23\" \"24\" \"25\"\n\nnames(coli_genomes[3]) &lt;- \"Year\"\nnames(coli_genomes)[3] &lt;- \"Year\"\ncolnames(coli_genomes[3]) &lt;- \"Year\"\n\nSome of the columns include ‘chr’ data that may be actually a categorical variable, so we can code them as factor. Using the expression as.factor() you can check whether the data would correspond to a text or a categorical variable.\n\ncoli_genomes$Source &lt;- as.factor(coli_genomes$Source)\ncoli_genomes$Phylogroup &lt;- as.factor(coli_genomes$Phylogroup)\n\nstr(coli_genomes)  #dataframe estructure updated\n\n'data.frame':   25 obs. of  16 variables:\n $ Strain             : chr  \"LREC237\" \"LREC239\" \"LREC240\" \"LREC241\" ...\n $ Biosample          : chr  \"SAMN14278613\" \"SAMN14278614\" \"SAMN14278615\" \"SAMN14278616\" ...\n $ Year               : int  NA 2010 2008 NA 2011 2007 2006 2006 2010 2013 ...\n $ Source             : Factor w/ 4 levels \"Avian \",\"Human\",..: 3 3 3 2 4 4 4 4 4 3 ...\n $ Phylogroup         : Factor w/ 4 levels \"A\",\"B1\",\"C\",\"D\": 4 3 2 1 1 1 1 1 3 4 ...\n $ Serotype           : chr  \"ONT:H28\" \"O153:H19\" \"O76:H30\" \"O78:H11\" ...\n $ Clonotype          : chr  \"CH23-331\" \"CH4-25\" \"CH29-38\" \"CH11-41\" ...\n $ Sequence.Type      : chr  \"ST524\" \"ST88\" \"ST156\" \"ST48\" ...\n $ VF                 : int  18 14 10 5 5 7 4 2 10 22 ...\n $ No..Plasmids       : int  3 3 2 3 9 3 7 7 1 4 ...\n $ kmer               : int  117 117 89 117 89 93 115 115 113 113 ...\n $ Contigs            : int  223 159 114 212 320 158 277 203 131 215 ...\n $ N50                : int  272287 323172 270767 112160 45936 106897 89185 94368 326769 248158 ...\n $ longest.contig..bp.: int  662555 760527 738861 285056 128053 369508 281444 280268 451887 504233 ...\n $ total.assembled.bp : int  5341632 5415613 4875343 5167401 4858138 4638334 5406295 4796593 5173794 5364777 ...\n $ contigs...1kb      : int  74 57 47 101 212 93 155 114 56 76 ...\n\n\nHow many levels are there in Source?? It is not uncommon to see some mistake in our data, usually made when the data were recorded, for example a space may have been inserted before a data value. By default this white space will be kept in the R environment, such that ‘Human’ will be recognized as a different value than ‘Human’. In order to avoid this type of error, we can use the strip.white argument.\n\nunique(coli_genomes$Source)\n\n[1] Human    Human    Porcine  Avian   \nLevels: Avian  Human Human  Porcine \n\ntable(coli_genomes$Source)\n\n\n  Avian     Human   Human  Porcine  \n       3        1       16        5 \n\ncoli_genomes &lt;- read.csv2(file = \"data/coli_genomes.csv\", strip.white = TRUE)\ncoli_genomes$Source &lt;- as.factor(coli_genomes$Source)\ncoli_genomes$Phylogroup &lt;- as.factor(coli_genomes$Phylogroup)\n\nunique(coli_genomes$Source)\n\n[1] Human   Porcine Avian  \nLevels: Avian Human Porcine\n\n\nAt this point, you may consider that writing the name of the dataframe every time that you want to work with it can be repetitive. In fact, we don’t need to do it.\n\nattach(coli_genomes)  #attach\ntable(Source)\n\nSource\n  Avian   Human Porcine \n      3      17       5 \n\ndetach(coli_genomes)\n\nNote that attach can be used for any R object, including dataframes, lists, vectors, packages… Once attached, R will consider those objects as databases, located in new, temporal environments."
  },
  {
    "objectID": "r3.html#renaming-changing-and-adding-variables",
    "href": "r3.html#renaming-changing-and-adding-variables",
    "title": "R3: Read and write data in R",
    "section": "4.2 Renaming, changing and adding variables",
    "text": "4.2 Renaming, changing and adding variables\nWe can also rename some variables to use more easy names.\n\nnames(coli_genomes)  #see all variable names\n\n [1] \"Strain\"              \"Biosample\"           \"Year.of.isolation\"  \n [4] \"Source\"              \"Phylogroup\"          \"Serotype\"           \n [7] \"Clonotype\"           \"Sequence.Type\"       \"VF\"                 \n[10] \"No..Plasmids\"        \"kmer\"                \"Contigs\"            \n[13] \"N50\"                 \"longest.contig..bp.\" \"total.assembled.bp\" \n[16] \"contigs...1kb\"      \n\n# rename variables\nnames(coli_genomes)[3] &lt;- \"Year\"\nnames(coli_genomes)[10] &lt;- \"Plasmids\"\nnames(coli_genomes)[15] &lt;- \"Assembly_length\"\nnames(coli_genomes)[16] &lt;- \"contigs1kb\"\n# check\nnames(coli_genomes)\n\n [1] \"Strain\"              \"Biosample\"           \"Year\"               \n [4] \"Source\"              \"Phylogroup\"          \"Serotype\"           \n [7] \"Clonotype\"           \"Sequence.Type\"       \"VF\"                 \n[10] \"Plasmids\"            \"kmer\"                \"Contigs\"            \n[13] \"N50\"                 \"longest.contig..bp.\" \"Assembly_length\"    \n[16] \"contigs1kb\"         \n\n\nWe are going to simplify our dataframe by dropping variables:\n\ncoli_genomes &lt;- coli_genomes[-c(9:11), ]\n# this can be also used to remove rows\ncoli_genomes[, -1]\n\n      Biosample Year  Source Phylogroup Serotype  Clonotype Sequence.Type VF\n1  SAMN14278613   NA   Human          D  ONT:H28   CH23-331         ST524 18\n2  SAMN14278614 2010   Human          C O153:H19     CH4-25          ST88 14\n3  SAMN14278615 2008   Human         B1  O76:H30    CH29-38         ST156 10\n4  SAMN14278616   NA   Human          A  O78:H11    CH11-41          ST48  5\n5  SAMN14278617 2011 Porcine          A  ONT:HNM     CH7-54         ST746  5\n6  SAMN14278618 2007 Porcine          A   O9:H37     CH7-31        ST3011  7\n7  SAMN14278619 2006 Porcine          A   O2:H32    CH11-23          ST10  4\n8  SAMN14278620 2006 Porcine          A  ONT:H45    C11-398       ST10888  2\n12 SAMN14278624 2013   Human          D O145:H28   CH23-331          ST32 22\n13 SAMN14278625 2013   Human          D O145:H28   CH23-331         ST137 22\n14 SAMN14278626 2013   Human          D O145:H28   CH23-331          ST32 20\n15 SAMN14278627 2013   Human          A  ONT:H37     C11-54          ST48  1\n16 SAMN14278628 2013   Avian          A  ONT:H19    CH94-23         ST347  2\n17 SAMN14278629 2011   Avian         B1 O142:H30     C41-35         ST359  9\n18 SAMN14278630 2005   Avian          C  O78:H19     CH4-27          ST88 11\n19 SAMN14278631 2012   Human          C   O8:H19     CH4-54          ST88 14\n20 SAMN14278632 2012   Human          C   O9:H19     CH4-27          ST88 14\n21 SAMN14278633 2012   Human          A    O9:H4     CH7-34          ST46  8\n22 SAMN14278634 2015   Human          C   O9:H19 CH4like-27       ST10890 13\n23 SAMN14278635 2012   Human          A  ONT:H33    CH11-54          ST10  2\n24 SAMN14278636 2016   Human          A  O98:H26    CH27-23        ST8233  2\n25 SAMN14278637 2012   Human         B1  O66:H10     CH4-32        ST1049  4\n   Plasmids kmer Contigs    N50 longest.contig..bp. Assembly_length contigs1kb\n1         3  117     223 272287              662555         5341632         74\n2         3  117     159 323172              760527         5415613         57\n3         2   89     114 270767              738861         4875343         47\n4         3  117     212 112160              285056         5167401        101\n5         9   89     320  45936              128053         4858138        212\n6         3   93     158 106897              369508         4638334         93\n7         7  115     277  89185              281444         5406295        155\n8         7  115     203  94368              280268         4796593        114\n12        1  115     376 200150              424527         5389075        131\n13        3  111     205 281589              617142         5340478         78\n14        1  113     206 182651              412836         5276782         95\n15        0  113     140 105396              272304         4507328         78\n16        0  117     134 110661              497785         4664768         77\n17        4  113     102 240847              460510         4992565         42\n18        4  113     108 405376             1190696         5196698         38\n19        2  113     108 281822             1140163         5252065         43\n20        4   91     224 140521              284241         5085107        110\n21        4   85     204  86565              300086         4915667        121\n22        3  113     171 326962              749412         5200701         77\n23        5  117     120 228491              576949         4881205         48\n24        4   89     114 187945              537848         4821342         53\n25        2  113      94 325747              822206         4839344         32\n\n\nWe know the ‘Assembly length’ and the number of ‘Contigs’, but we would like to represent the average contig length.\n\ncoli_genomes$average_contig &lt;- coli_genomes$Assembly_length/coli_genomes$Contigs"
  },
  {
    "objectID": "r5.html",
    "href": "r5.html",
    "title": "R5: Base plots in R",
    "section": "",
    "text": "Data visualization is a very important part of a data analysis because they can efficiently summarize large amounts of data in a graphical format and reveal new insights that are difficult to understand from the raw data. From a researcher’s or data analyst’s perspective, plotting datasets also helps you become familiar with the data and plan next steps in your analysis. It also allows you to identify statistical pitfalls with an initial plot.\n\n\n\n\n\n\nAnscombe’s quartet. Each of the four datasets consists of 11 data points (orange points) and have nearly identical statistical properties, including means, sample variances, Pearson’s sample correlation (r), and linear regression line (blue lines). Modified from Anscombe FJ. Graphs in statistical analysis. Am Stat 1973;27:17–21\n\n\nThis well-known quartet highlights the importance of graphing data prior to analysis, and why statistical reviewers often ask for such graphs to be made available. Check out also the Dinosaurus example in the reference 2 below.\n\n\n\nThere are many different types of graphs, each with their own strengths and use cases. One of the trickiest parts of the analysis process is choosing the right way to represent your data with one of these visualizations. The wrong chart can lead to confusion or misinterpretation of the data (see some examples of bad charts here).\nFrom a classical data analysis perspective, the first consideration in choosing the right plot is the nature of your variables. Some charts are recommended for numerical data (quantitative variables) and others for categorical data (qualitative variables). Then you should consider what role you want your data visualization to play, i.e., what question you want to answer or what message you want to convey. This depends on the number of variables as well as their distribution, grouping or correlation. There are some best practice guidelines, but ultimately you need to consider what is best for your data. What do you want to show? What chart best conveys your message? Is it a comparison between groups? Is it a frequency distribution of 1 variable?\nfor a guidance, you can use the Chartchooser below, by Andrew Abela.\n\n\n\nThe ExtremePresentation method for choosing a plot or chart.\n\n\nYou can see a description of some of the most common plot types, with many examples on books and dedicated R websites. I suggest to take a look to some of the suggested References below, or some quick examples, like those here or here. Rather than going through a wide list of plots, we are going to use some examples to learn some basic plotting and see the effect of plot selection in order to understand your data and use them to answer questions.\n\n\n\nR has a number of built-in tools for diverse graph types such as histograms, scatterplots, stripcharts, bar charts, boxplots, and more. Indeed, there are many functions in R to produce plots ranging from the very basic to the highly complex. We will show a few examples and use the plots as an excuse to add some new tricks for data analysis.\nIn Lesson R8 we will use the ggplot2 package for efficient and advanced plot generation and customization. However, you will see that it’s sometimes useful to use the plotting functions in base R. These are installed by default with R and do not require any additional packages to be installed. They’re quick to type, straightforward to use in simple cases, and run very quickly. Then, if you want to do anything beyond very simple plots, though, it’s generally better to switch to ggplot2. In fact, once you already know how to use R’s base graphics, having these examples side by side will help you transition to using ggplot2 for when you want to make more sophisticated graphics.\n\n\n\n\n\n\nImportant\n\n\n\nThe function plot() is actually multifunctional and it can be used to generate different types of plots.\n\n\nIn the table and the examples below you can see how to use plot() for different plot types.\n\n\n\nUse of plot() function. Source: https://r-coder.com/plot-r/\n\n\nFor the following examples, we are going to review also some R functions to make up (mock or simulated) data restricted to certain distributions. For instance, using functions like rnorm() or dnorm() for generation of normal data or normal density curves. The same can be obtained for Poisson distribution with dpois() and rpois().\n\n#generate some sample data with normal distribution\nx &lt;- rnorm(500)\ny &lt;- x + rnorm(500)\nplot(x)\n\n\n\nhist(x,col=\"blue\")\n\n\n\nplot(x, y)\n\n\n\nplot(dnorm(0:100,mean=50,sd=5))\n\n\n\n\nWe can also change some of the plot parameters to change the plot appearance.\n\n#customized Example\nplot(x, y, pch = 21,\n     bg = rgb(1,0,0,0.5),   # Fill color\n     col = \"red\", # Border color\n     cex = 3,      # Symbol size\n     lwd = 3)      # Border width\n\n\n\n\nNote that colors can be specified as a name or code (RGB or HEX). In the case of RGB code, we provide the three values in the range [0,1] for red, green, and blue. We can also introduce an optional fourth value that correspond to the alpha, also from 0 (transparent) to 1 (opaque). See below for more details about changing points and line shape and colors.\n\n\n\n\nWe have a vector in a RData file called primes.RData that we would like to plot.\n\n\n\n\n\n\nCross-lesson tip\n\n\n\nIf you have not worked with the R3 lesson yet, you can take a quick look at how we can save and load objects into a RData file.\n\n\nHow would you load the vector?\n\n load(data/primes.RData) load(“data/primes.RData”) open(“data/primes.RData”)\n\nNow we want to plot the vector. You may try different plots, but think which plot help you to answer the following question\nIn which quartile of the vector values there are more elements?\n\n plot(new_vec) hist(new_vec, breaks=c(0,25,50,75,100)) boxplot(new_vec) hist(new_vec, breaks=c(0,25,50,75,100))\n\nYes, a boxplot is the best choice here.\n\n\n\nSee the right plot\n\nload(\"data/primes.RData\")\nboxplot(new_vec)\n\n\n\n\n\nHere’s how to interpret this boxplot:\n\nThe bottom whisker displays the minimum value.\nThe bottom line of the box displays the first quartile value.\nThe black bar in the middle of the box displays the second quartile value.\nThe top line of the box displays the third quartile value (also known as the median).\nThe top whisker displays the maximum value.\n\nWe can also easily calculate the quartiles of a given dataset in R by using the quantile() function.\n\nload(\"data/primes.RData\")\nquantile(new_vec)\n\n  0%  25%  50%  75% 100% \n   2   17   41   67   97 \n\n\nCompare the output with the boxplot and interpret the numbers.\n\n\n\nAs an example, we are going to read again the file coli_genomes_renamed.csv that we used in the previous lesson and export it ready for MS Excel.\n\n\n\n\n\n\nCross-lesson tip\n\n\n\nIf you have not worked with the R3 lesson yet, you can take a quick look at how we can open and save a table in R.\n\n\nNow let’s play with different plots of our data and try to save one.\n\n#open the data\ncoli_genomes &lt;- read.csv(file = 'data/coli_genomes_renamed.csv', strip.white = TRUE, stringsAsFactors = TRUE)\n#attach it to save time and code writing (optional!)\nattach(coli_genomes)\n#one variable\nplot(Year)\n\n\n\n#histogram\nhist(Year)\n\n\n\n#a factor\nplot(Source)\n\n\n\n#two variables\nplot(Contigs, kmer)\n\n\n\n#factor + numeric variable and saving the plot\npng(file=\"plot1.png\")  #give it a file name\nplot(Source,Contigs)  #construct the plot\ndev.off()  #save\n\nquartz_off_screen \n                2 \n\ndetach(coli_genomes) #detach\n\nAs shown in the example, in order to save a plot, we must follow three steps:\n\nOpen the file indicating the format: png(), jpg(), svg(), postscript(), bmp(), win.metafile(), or pdf().\nPlot the data.\nClose the file: dev.off().\n\nAlternatively, you can save the plot using the Plot menu or the Plots panel: Export –&gt; Save as Image or Save as PDF.\n\n\n\nAs you may know, the R function cor() calculate the correlation coefficient between two or more vectors and cor.test() allow us to quickly perform a correlation test between two variables to know if the correlation is statistically significant. However, a quick plot can be also very useful.\nIn our example dataframe, we have some features of a list of E. coli isolates and the basic stats of the genome sequencing. Regarding this data, do you think that the number of contigs &gt; 1kb in the genome assemblies (contigs1kb) correlates with the total number of contigs (Contigs), or the average contig length (average_contig)? Let’s check the data using simple plots with the plot() function. Since we are going to make two plots, we will layout them together using a par option.\n\n\n\n\n\n\nPlot parameters set up with par\n\n\n\nNote that par can be used to set many graphical parameters. These options are stored in a list R object, that you can get using par() (with no arguments).\n\n\n\n#first we can save original settings (optional)\noldpar &lt;- par() \npar(mfrow = c(1, 2)) #graph area in two columns\n\n#correlation plots\nplot(coli_genomes$contigs1kb ~ coli_genomes$Contigs, xlab=\"Contigs\", ylab=\"Contigs &gt; 1kb\")\n\nplot(coli_genomes$contigs1kb ~ coli_genomes$average_contig, xlab=\"Average contig\", ylab=\"Contigs &gt; 1kb\")\n\n\n\n\nWhat do you think? Now that we have seen the linear relationship pictorially in the scatter plot, we should plot the linear regression line and analyze the correlation.\n\n\n\n\n\n\nREMINDER - Linear model and correlation in R\n\n\n\nLinear regression analysis is used to predict the value of a variable based on the value of another variable. In R, you can calculate the linear regression equation with the function lm(). The lm() function takes in two main arguments, (1) Formula and (2) Data. The data is typically a data.frame and the formula is a object of class formula (with a diacritical mark like that over the Spanish letter ñ, ~). But the most common convention is to write out the formula directly in place of the argument as written below.\nThen, to fully check the correlation (and avoid situations like in the Anscombe’s quartet above, you must also remember that correlation coefficient can be calculated with the function cor().\n\n\nLet’s obtain and plot the linear model:\n\n#linear model\nmodelito &lt;- lm(coli_genomes$contigs1kb ~ coli_genomes$Contigs)\nsummary(modelito)  #is the linear model significant???\n\n\nCall:\nlm(formula = coli_genomes$contigs1kb ~ coli_genomes$Contigs)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-53.475  -8.646  -3.300  14.840  55.947 \n\nCoefficients:\n                     Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)          -6.36290   12.90558  -0.493    0.627    \ncoli_genomes$Contigs  0.50755    0.06634   7.651 2.31e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 22.55 on 20 degrees of freedom\nMultiple R-squared:  0.7453,    Adjusted R-squared:  0.7326 \nF-statistic: 58.54 on 1 and 20 DF,  p-value: 2.306e-07\n\n\n\n\n\n\n\n\nTip\n\n\n\nRemember that the results of lm(), cor.test(), and all other tests, are R objects (usually lists) than can be used to retrieve the results or plot the values.\n\n\n\n#set par (we need to set up the par in every code chunk)\npar(mfrow = c(1, 2))\n#correlation plots with line\nplot(coli_genomes$contigs1kb ~ coli_genomes$Contigs, xlab=\"Contigs\", ylab=\"Contigs &gt; 1kb\")\nabline(modelito, col=\"red\")\n# we can include the lm() in the plot, without calculating it before\nplot(coli_genomes$contigs1kb ~ coli_genomes$average_contig, xlab=\"Average contig\", ylab=\"Contigs &gt; 1kb\")\nabline(lm(coli_genomes$contigs1kb ~ coli_genomes$average_contig), col=\"red\")\n\n\n\n#now we will check with a cor.test and add some text to the plot\n(test1 &lt;- cor.test(coli_genomes$contigs1kb, coli_genomes$Contigs))\n\n\n    Pearson's product-moment correlation\n\ndata:  coli_genomes$contigs1kb and coli_genomes$Contigs\nt = 7.651, df = 20, p-value = 2.306e-07\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.6945248 0.9420476\nsample estimates:\n     cor \n0.863334 \n\n(test2 &lt;- cor.test(coli_genomes$contigs1kb, coli_genomes$average_contig))\n\n\n    Pearson's product-moment correlation\n\ndata:  coli_genomes$contigs1kb and coli_genomes$average_contig\nt = -7.8453, df = 20, p-value = 1.574e-07\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n -0.9444427 -0.7055990\nsample estimates:\n       cor \n-0.8687624 \n\nstr(test1)\n\nList of 9\n $ statistic  : Named num 7.65\n  ..- attr(*, \"names\")= chr \"t\"\n $ parameter  : Named int 20\n  ..- attr(*, \"names\")= chr \"df\"\n $ p.value    : num 2.31e-07\n $ estimate   : Named num 0.863\n  ..- attr(*, \"names\")= chr \"cor\"\n $ null.value : Named num 0\n  ..- attr(*, \"names\")= chr \"correlation\"\n $ alternative: chr \"two.sided\"\n $ method     : chr \"Pearson's product-moment correlation\"\n $ data.name  : chr \"coli_genomes$contigs1kb and coli_genomes$Contigs\"\n $ conf.int   : num [1:2] 0.695 0.942\n  ..- attr(*, \"conf.level\")= num 0.95\n - attr(*, \"class\")= chr \"htest\"\n\n\n\nplot(coli_genomes$contigs1kb ~ coli_genomes$Contigs, xlab=\"Contigs\", ylab=\"Contigs &gt; 1kb\")\nabline(lm(coli_genomes$contigs1kb ~ coli_genomes$Contigs), col=\"red\")\n#now add the text in a defined position\ntext(200,200,paste(\"Pearson r2=\",round(test1$estimate,2)))\n\n\n\nplot(coli_genomes$contigs1kb ~ coli_genomes$average_contig, xlab=\"Average contig\", ylab=\"Contigs &gt; 1kb\")\nabline(lm(coli_genomes$contigs1kb ~ coli_genomes$average_contig), col=\"red\")\ntext(40000,200,paste(\"Pearson r2=\",round(test2$estimate,2)))\n\n\n\n\nIn a step further you can check multiple correlations in a single plot.\n\n#oh wait! why only one-vs-one?\nplot(coli_genomes[,c(\"VF\",\"Plasmids\",\"kmer\",\"Contigs\",\"N50\",\"longest.contig..bp.\",\"Assembly_length\",\"contigs1kb\",\"average_contig\")], main = \"Multiple Correlation plot\")\n\n\n\n\nNow, you have a quick info about possible variable correlations.\n\n\n\n\nFor this exercise we are going to use a dataset called zebrafish_data.csv. This file contains the results of an experiment in which a collaborator scored the number of metastatic cancer cells upon the expression of different transcripts of the EFNA3 gene. Each transcript is cloned into a pLoC plasmid, and we have negative (empty plasmid) and positive controls (wt EFNA3 transcript), as well as four transcript mutants. Let’s import and check the data.\n\n#read data\nZFdata &lt;- read.csv(\"data/Zebrafish_data.csv\")\nstr(ZFdata)\n\n'data.frame':   41 obs. of  6 variables:\n $ pLoC : int  36 32 10 26 15 23 17 14 44 12 ...\n $ EFNA3: int  35 33 17 25 89 36 40 36 35 37 ...\n $ NC1  : int  58 26 26 18 20 24 10 31 28 26 ...\n $ NC1s : int  11 11 19 12 12 20 7 104 116 11 ...\n $ NC2  : int  53 37 56 48 27 29 22 79 22 18 ...\n $ NC2s : int  40 43 19 18 33 29 29 25 28 47 ...\n\n\nHow would you construct barplots of the data from the six experimental conditions?\n\n hist(ZFdata) barplot(ZFdata) barplot(ZFdata$pLoC), and the same for each construct hist(ZFdata$pLoC), and the same for each construct\n\nLet’s see some examples:\n\n#some plots\nbarplot(ZFdata)\n\nError in barplot.default(ZFdata): 'height' must be a vector or a matrix\n\nbarplot(ZFdata$pLoC)\n\n\n\npar(mfrow=c(1,3)) #arrange the three plots in a row \n#we include a plot title with \"main\"\nbarplot(ZFdata$pLoC, col=\"red\", main=\"pLoc\")\nbarplot(ZFdata$EFNA3, col=\"green\", main=\"EFNA3\")\nbarplot(ZFdata$NC1s, col=\"blue\",main=\"NC1s\")\n\n\n\npar(mfrow=c(2,3)) #arrange the six plots in two rows\n#note the \"method\" option\nstripchart(ZFdata$pLoC, main=\"pLoc\")\nstripchart(ZFdata$pLoC, method=\"stack\", col=\"red\", main=\"pLoc\")\nstripchart(ZFdata$pLoC, method=\"overplot\", col=\"red\",  main=\"pLoc\")\nstripchart(ZFdata$pLoC, method=\"jitter\", col=\"red\", main=\"pLoc\")\nstripchart(ZFdata$EFNA3, method = \"stack\",col=\"green\", main=\"EFNA3\")\nstripchart(ZFdata$NC1s, method = \"stack\",col=\"blue\", main=\"N1cs\")\n\n\n\n#now histograms\npar(mfrow=c(1,3)) #arrange the three plots in a row \nhist(ZFdata$pLoC, col=\"red\",  main=\"pLoc\")\nhist(ZFdata$EFNA3, col=\"green\", main=\"EFNA3\")\nhist(ZFdata$NC1s, col=\"blue\", main=\"N1cs\")\n\n\n\n\nNow try to answer some questions about your data and obtained plots:\n1. Which construct has the strongest impact on the dissemination of metastatic cells?\n\n The empty plasmid pLoC WT EFNA3 NC1 NC1s NC2 NC2s I cannot say\n\n2. Which plot represent best these data?\n\n Histogram Barplot Boxplot Stripchart I am not sure\n\n3. Does a boxplot represent the same information than a histogram?\n\n No, not at all Yes, they are the same Yes, but a boxplot will show best the differences between my samples Yes, but a histogram will show best the differences between my samples\n\n4. Does a barplot represent the same information than a boxplot?\n\n No, a barplot represents data frequencies/distribution No, boxplots and histograms represent data frequencies/distribution Yes, they alike\n\nNow, we are going to represent the same data again, introducing some more customization\n\n\n\n\n\n\n\n\n\n\n\nCan you reproduce the above plots?\n\n\n\nAnswer\n\n#new par settings\npar(mfrow = c(1, 3), cex.lab = 1, cex = 1, lwd = 2)\n#plotting\nhist(ZFdata$pLoC, col=rgb(1,0,0,0.5),  main=\"pLoc\", ylim = c(0,20), xlim = c(0,120), xlab = \"Number of Metastatic cells\")\nhist(ZFdata$EFNA3, col=rgb(0,1,0,0.5),  main=\"EFNA3\", ylim = c(0,20), xlim = c(0,120), xlab = \"Number of Metastatic cells\")\nhist(ZFdata$NC1s, col=rgb(0,0,1,0.5),  main=\"NC1s\", ylim = c(0,20), xlim = c(0,120), xlab = \"Number of Metastatic cells\")\n\nstripchart(ZFdata$pLoC, method=\"jitter\", pch=19, col=rgb(1,0,0,0.5), vertical=TRUE,  main=\"pLoc\", ylim = c(0,120), xlab = \"Number of Metastatic cells\")\nstripchart(ZFdata$EFNA3, method=\"jitter\", pch=19, col=rgb(0,1,0,0.5), vertical=TRUE, main=\"EFNA3\", ylim = c(0,120), xlab = \"Number of Metastatic cells\")\nstripchart(ZFdata$EFNA3, method=\"jitter\", pch=19, col=rgb(0,1,0,0.5), vertical=TRUE, main=\"EFNA3\", ylim = c(0,120), xlab = \"Number of Metastatic cells\")\n\nboxplot(ZFdata$pLoC, col=rgb(1,0,0,0.5),  ylim = c(0,120), xlab = \"Number of Metastatic cells\", main=\"pLoc\")\nboxplot(ZFdata$EFNA3, col=rgb(0,1,0,0.5), ylim = c(0,120), xlab = \"Number of Metastatic cells\",  main=\"EFNA3\")\nboxplot(ZFdata$NC1s, col=rgb(0,0,1,0.5), ylim = c(0,120), xlab = \"Number of Metastatic cells\", main=\"N1cs\")\n\n\nDo you think, you can answer better the questions now?\nBeyond some basic examples of plotting in R, the take-home message of this example is that the type of plot and the plot parameters (in this case the scale) can be essential for correct interpretation of the data and if they are not properly adjusted the plot can be strongly misleading.\nThe stripchart and the boxplot strongly suggest that NC2s is probably the strongest transcript, but that is not shown in the barplot. These plots clearly show that barplots are intended for single values (categorical data) and can mislead your conclusions.\n\n\n\nWe will still use the data from the zebrafish experiment here\nIn the previous plots, in order to compare three conditions, we needed to make three independent plots. However, in the table, there are six conditions, and it is not very difficult to imagine experiments that might result in a table with even more conditions. How could you plot that? The key question is, different conditions means different variables? In other words:\nHow many variables are there in the Zebrafish dataset?\n\n 3 variables, WT, empty plasmid and 4 mutants 6, one for each expressed transcript 2 variables, the (1) plasmid/expressed transcript and (2) the number of metastatic cells\n\nIn data analysis (check Lesson R6), particularly when you want to compare many variables in different groups, it is more handy to create a stacked table or datamatrix. Stacked table are also often referred to as narrow tables. In contrast, the tables with different conditions (of a same variable) in different columns are named wide table or unstacked. The code below shows how to stack and plot your data by groups using the function stack().\n\nZF_stacked &lt;- stack(ZFdata)\n\n#you can also define a colors vector that can be reused\ncolorines=c(rgb(1,0,0,0.5),rgb(0,1,0,0.5),rgb(0,0,1,0.5),rgb(1,0.5,0,0.5),rgb(0.5,0.5,0.5,0.5),rgb(0,1,1,0.5)) \nboxplot(ZF_stacked$values ~ ZF_stacked$ind,  col=colorines)\n\n\n\nstripchart(ZF_stacked$values ~ ZF_stacked$ind, vertical = TRUE, method=\"jitter\", col=colorines, pch=19, cex=1, ylab=\"Number of cells\", xlab=\"Plasmid\")\n\n\n\n\n\n\n\nThere are many options to customize your plots, including font type and size, point shape, line type… You can see more info on the References section below. Let’s see some examples using code I borrow from https://r-coder.com/plot-r/\n\n#point shape with \"pch\"\nr &lt;- c(sapply(seq(5, 25, 5), function(i) rep(i, 5)))\nt &lt;- rep(seq(25, 5, -5), 5)\n\nplot(r, t, pch = 1:25, cex = 3, yaxt = \"n\", xaxt = \"n\",\n     ann = FALSE, xlim = c(3, 27), lwd = 1:3)\ntext(r - 1.5, t, 1:25)\n\n\n\n#line type with \"lty\"\nM &lt;- matrix(1:36, ncol = 6)\nmatplot(M, type = c(\"l\"), lty = 1:6, col = \"black\", lwd = 3)\n\n# Just to indicate the line types in the plot\nj &lt;- 0\ninvisible(sapply(seq(4, 40, by = 6),\n                 function(i) {\n                   j &lt;&lt;- j + 1\n                   text(2, i, paste(\"lty =\", j))}))\n\n\n\n#plot box\npar(mfrow = c(2, 3))\n\n#plots\nplot(x, y, bty = \"o\", main = \"Default\")\nplot(x, y, bty = \"7\", main = \"bty = '7'\")\nplot(x, y, bty = \"L\", main = \"bty = 'L'\")\nplot(x, y, bty = \"U\", main = \"bty = 'U'\")\nplot(x, y, bty = \"C\", main = \"bty = 'C'\")\nplot(x, y, bty = \"n\", main = \"bty = 'n'\")\n\n\n\npar(mfrow = c(1, 1))\n\n\n\n\nNow let’s think again in our E. coli genomes. How would you add more layers of information to the plot, like labels of specific points?\n\n\n\n\n\n\n\n\nAnswer\n\n#point label, but only some \"selected\" points\n\n#step1: create a vector with the selection\nselected &lt;- c(7, 17, 18)\n#step2: make a plot\nplot(coli_genomes$contigs1kb ~ coli_genomes$Contigs, pch=19,col=rgb(1,0,0,0.5), xlab=\"Contigs\", ylab=\"Contigs &gt; 1kb\")\n\n#step 3: add the labels as a text layer\n#note that you can use the formula for the text coordinates\ntext(coli_genomes$contigs1kb[selected] ~ coli_genomes$Contigs[selected],\n     labels = coli_genomes$Strain[selected],\n     cex = 0.6, pos = 4, col = \"red\")\n\n\nYou can look for more custom options because there are a lot. I also suggest looking at the identify() function, which allows the quick interactive identification and labeling of selected points.\nNow, we repeat the scatterplot above of contigs1kb vs. Contigs, but instead of labels, coloring the points by Source as in the plot below. Finally, use the function legend() to add a legend.\n\n\n\n\n\n\n\n\nHint\n\n#Think in a way to use the variable 'Source' and conditionally recode it as colors\n#Then, a recursive way will help you to generate a vector to color all the elements in the plot\n\n\n\n\n\nAnswer\n\n#recode the source as color\n#step 1: define an empty vector (not required here, but better to do it)\ncolorines &lt;- c()\n#step 2: use a loop to run over all the source vector\nfor (i in 1:nrow(coli_genomes)){\n#step 3: use switch() to recode the sources as colors\n#note that Source is a factor but we need to treat it as a character here\n  colorines[i] &lt;- switch(as.character(coli_genomes$Source[i]),\n      Avian=rgb(1,0,0,0.4),\n      Human=rgb(0,1,0,0.4),\n      Porcine=rgb(0,0,1,0.4))                   \n}\n#plot\nplot(coli_genomes$contigs1kb ~ coli_genomes$Contigs, pch=21,bg=colorines, xlab=\"Contigs\", ylab=\"Contigs &gt; 1kb\")\n\n#legend\n#the function unique() is important here, can you figure out why?\nlegend(100,200,legend=unique(coli_genomes$Source),fill=unique(colorines))"
  },
  {
    "objectID": "r5.html#selecting-the-right-plot",
    "href": "r5.html#selecting-the-right-plot",
    "title": "R5: Base plots in R",
    "section": "",
    "text": "Data visualizations are a vital component of a data analysis, as they have the capability of summarizing large amounts of data efficiently in a graphical format and bring out new insights that can be difficult to understand from raw data. There are many chart types available, each with its own strengths and use cases. One of the trickiest parts of the analysis process is choosing the right way to represent your data using one of these visualizations. A wrong plot can lead to confusion or data misinterpretation (see some examples of bad graphs here).\nFrom the perspective of classical data analysis, the first consideration to select the right plot is the nature of your variables. Some plots are recommended for numerical data (quantitative variables) and other for categorical data (qualitative variables). Then, you should considering the role for your data visualization, i.e, question you want to address or the message you want to transmit. That will depend on how many variables, as well as their distribution, grouping or correlation. There are some best practice guidelines, but at the end of the day, you need to consider what is best for your data. What do you want to show? What graph will best communicate your message? Is it a comparison between groups? Is it the frequency distribution of 1 variable?\nAs a guidance, you can use the below cheatsheet, taken from Nathan Yau’s blog Flowingdata:\n\nYou can see a description of some of the most common plot types, with many examples on books and dedicated R websites. I suggest to take a look to some of the suggested References below, or some quick examples, like those here or here. Rather than going through a wide list of plots, we are going to use some examples to learn some basic plotting and see the effect of plot selection in order to understand your data and use them to answer questions."
  },
  {
    "objectID": "r5.html#quick-plotting-in-r",
    "href": "r5.html#quick-plotting-in-r",
    "title": "R5: Base plots in R",
    "section": "",
    "text": "R has a number of built-in tools for diverse graph types such as histograms, scatterplots, stripcharts, bar charts, boxplots, and more. Indeed, there are many functions in R to produce plots ranging from the very basic to the highly complex. We will show a few examples and use the plots as an excuse to add some new tricks for data analysis.\nIn Lesson R8 we will use the ggplot2 package for efficient and advanced plot generation and customization. However, you will see that it’s sometimes useful to use the plotting functions in base R. These are installed by default with R and do not require any additional packages to be installed. They’re quick to type, straightforward to use in simple cases, and run very quickly. Then, if you want to do anything beyond very simple plots, though, it’s generally better to switch to ggplot2. In fact, once you already know how to use R’s base graphics, having these examples side by side will help you transition to using ggplot2 for when you want to make more sophisticated graphics.\n\n\n\n\n\n\nImportant\n\n\n\nThe function plot() is actually multifunctional and it can be used to generate different types of plots.\n\n\nIn the table and the examples below you can see how to use plot() for different plot types.\n\n\n\nUse of plot() function. Source: https://r-coder.com/plot-r/\n\n\nFor the following examples, we are going to review also some R functions to make up (mock or simulated) data restricted to certain distributions. For instance, using functions like rnorm() or dnorm() for generation of normal data or normal density curves. The same can be obtained for Poisson distribution with dpois() and rpois().\n\n#generate some sample data with normal distribution\nx &lt;- rnorm(500)\ny &lt;- x + rnorm(500)\nplot(x)\n\n\n\nhist(x,col=\"blue\")\n\n\n\nplot(x, y)\n\n\n\nplot(dnorm(0:100,mean=50,sd=5))\n\n\n\n\nWe can also change some of the plot parameters to change the plot appearance.\n\n#customized Example\nplot(x, y, pch = 21,\n     bg = rgb(1,0,0,0.5),   # Fill color\n     col = \"red\", # Border color\n     cex = 3,      # Symbol size\n     lwd = 3)      # Border width\n\n\n\n\nNote that colors can be specified as a name or code (RGB or HEX). In the case of RGB code, we provide the three values in the range [0,1] for red, green, and blue. We can also introduce an optional fourth value that correspond to the alpha, also from 0 (transparent) to 1 (opaque). See below for more details about changing points and line shape and colors."
  },
  {
    "objectID": "r5.html#quick-exercise-i",
    "href": "r5.html#quick-exercise-i",
    "title": "R5: Base plots in R",
    "section": "",
    "text": "We have a vector in a RData file called primes.RData that we would like to plot.\n\n\n\n\n\n\nCross-lesson tip\n\n\n\nIf you have not worked with the R3 lesson yet, you can take a quick look at how we can save and load objects into a RData file.\n\n\nHow would you load the vector?\n\n load(data/primes.RData) load(“data/primes.RData”) open(“data/primes.RData”)\n\nNow we want to plot the vector. You may try different plots, but think which plot help you to answer the following question\nIn which quartile of the vector values there are more elements?\n\n plot(new_vec) hist(new_vec, breaks=c(0,25,50,75,100)) boxplot(new_vec) hist(new_vec, breaks=c(0,25,50,75,100))\n\nYes, a boxplot is the best choice here.\n\n\n\nSee the right plot\n\nload(\"data/primes.RData\")\nboxplot(new_vec)\n\n\n\n\n\nHere’s how to interpret this boxplot:\n\nThe bottom whisker displays the minimum value.\nThe bottom line of the box displays the first quartile value.\nThe black bar in the middle of the box displays the second quartile value.\nThe top line of the box displays the third quartile value (also known as the median).\nThe top whisker displays the maximum value.\n\nWe can also easily calculate the quartiles of a given dataset in R by using the quantile() function.\n\nload(\"data/primes.RData\")\nquantile(new_vec)\n\n  0%  25%  50%  75% 100% \n   2   17   41   67   97 \n\n\nCompare the output with the boxplot and interpret the numbers."
  },
  {
    "objectID": "r5.html#plot-customization",
    "href": "r5.html#plot-customization",
    "title": "R5: Base plots in R",
    "section": "",
    "text": "There are many options to customize your plots, including font type and size, point shape, line type… You can see more info on the References section below. Let’s see some examples using code I borrow from https://r-coder.com/plot-r/\n\n#point shape with \"pch\"\nr &lt;- c(sapply(seq(5, 25, 5), function(i) rep(i, 5)))\nt &lt;- rep(seq(25, 5, -5), 5)\n\nplot(r, t, pch = 1:25, cex = 3, yaxt = \"n\", xaxt = \"n\",\n     ann = FALSE, xlim = c(3, 27), lwd = 1:3)\ntext(r - 1.5, t, 1:25)\n\n\n\n#line type with \"lty\"\nM &lt;- matrix(1:36, ncol = 6)\nmatplot(M, type = c(\"l\"), lty = 1:6, col = \"black\", lwd = 3)\n\n# Just to indicate the line types in the plot\nj &lt;- 0\ninvisible(sapply(seq(4, 40, by = 6),\n                 function(i) {\n                   j &lt;&lt;- j + 1\n                   text(2, i, paste(\"lty =\", j))}))\n\n\n\n#plot box\npar(mfrow = c(2, 3))\n\n#plots\nplot(x, y, bty = \"o\", main = \"Default\")\nplot(x, y, bty = \"7\", main = \"bty = '7'\")\nplot(x, y, bty = \"L\", main = \"bty = 'L'\")\nplot(x, y, bty = \"U\", main = \"bty = 'U'\")\nplot(x, y, bty = \"C\", main = \"bty = 'C'\")\nplot(x, y, bty = \"n\", main = \"bty = 'n'\")\n\n\n\npar(mfrow = c(1, 1))"
  },
  {
    "objectID": "r5.html#plot-your-data-and-save-the-plot",
    "href": "r5.html#plot-your-data-and-save-the-plot",
    "title": "R5: Base plots in R",
    "section": "",
    "text": "As an example, we are going to read again the file coli_genomes_renamed.csv that we used in the previous lesson and export it ready for MS Excel.\n\n\n\n\n\n\nCross-lesson tip\n\n\n\nIf you have not worked with the R3 lesson yet, you can take a quick look at how we can open and save a table in R.\n\n\nNow let’s play with different plots of our data and try to save one.\n\n#open the data\ncoli_genomes &lt;- read.csv(file = 'data/coli_genomes_renamed.csv', strip.white = TRUE, stringsAsFactors = TRUE)\n#attach it to save time and code writing (optional!)\nattach(coli_genomes)\n#one variable\nplot(Year)\n\n\n\n#histogram\nhist(Year)\n\n\n\n#a factor\nplot(Source)\n\n\n\n#two variables\nplot(Contigs, kmer)\n\n\n\n#factor + numeric variable and saving the plot\npng(file=\"plot1.png\")  #give it a file name\nplot(Source,Contigs)  #construct the plot\ndev.off()  #save\n\nquartz_off_screen \n                2 \n\ndetach(coli_genomes) #detach\n\nAs shown in the example, in order to save a plot, we must follow three steps:\n\nOpen the file indicating the format: png(), jpg(), svg(), postscript(), bmp(), win.metafile(), or pdf().\nPlot the data.\nClose the file: dev.off().\n\nAlternatively, you can save the plot using the Plot menu or the Plots panel: Export –&gt; Save as Image or Save as PDF."
  },
  {
    "objectID": "r5.html#adding-elements-to-your-plot",
    "href": "r5.html#adding-elements-to-your-plot",
    "title": "R5: Base plots in R",
    "section": "",
    "text": "As you may know, the R function cor() calculate the correlation coefficient between two or more vectors and cor.test() allow us to quickly perform a correlation test between two variables to know if the correlation is statistically significant. However, a quick plot can be also very useful.\nIn our example dataframe, we have some features of a list of E. coli isolates and the basic stats of the genome sequencing. Regarding this data, do you think that the number of contigs &gt; 1kb in the genome assemblies (contigs1kb) correlates with the total number of contigs (Contigs), or the average contig length (average_contig)? Let’s check the data using simple plots with the plot() function. Since we are going to make two plots, we will layout them together using a par option.\n\n\n\n\n\n\nPlot parameters set up with par\n\n\n\nNote that par can be used to set many graphical parameters. These options are stored in a list R object, that you can get using par() (with no arguments).\n\n\n\n#first we can save original settings (optional)\noldpar &lt;- par() \npar(mfrow = c(1, 2)) #graph area in two columns\n\n#correlation plots\nplot(coli_genomes$contigs1kb ~ coli_genomes$Contigs, xlab=\"Contigs\", ylab=\"Contigs &gt; 1kb\")\n\nplot(coli_genomes$contigs1kb ~ coli_genomes$average_contig, xlab=\"Average contig\", ylab=\"Contigs &gt; 1kb\")\n\n\n\n\nWhat do you think? Now that we have seen the linear relationship pictorially in the scatter plot, we should plot the linear regression line and analyze the correlation.\n\n\n\n\n\n\nREMINDER - Linear model and correlation in R\n\n\n\nLinear regression analysis is used to predict the value of a variable based on the value of another variable. In R, you can calculate the linear regression equation with the function lm(). The lm() function takes in two main arguments, (1) Formula and (2) Data. The data is typically a data.frame and the formula is a object of class formula (with a diacritical mark like that over the Spanish letter ñ, ~). But the most common convention is to write out the formula directly in place of the argument as written below.\nThen, to fully check the correlation (and avoid situations like in the Anscombe’s quartet above, you must also remember that correlation coefficient can be calculated with the function cor().\n\n\nLet’s obtain and plot the linear model:\n\n#linear model\nmodelito &lt;- lm(coli_genomes$contigs1kb ~ coli_genomes$Contigs)\nsummary(modelito)  #is the linear model significant???\n\n\nCall:\nlm(formula = coli_genomes$contigs1kb ~ coli_genomes$Contigs)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-53.475  -8.646  -3.300  14.840  55.947 \n\nCoefficients:\n                     Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)          -6.36290   12.90558  -0.493    0.627    \ncoli_genomes$Contigs  0.50755    0.06634   7.651 2.31e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 22.55 on 20 degrees of freedom\nMultiple R-squared:  0.7453,    Adjusted R-squared:  0.7326 \nF-statistic: 58.54 on 1 and 20 DF,  p-value: 2.306e-07\n\n\n\n\n\n\n\n\nTip\n\n\n\nRemember that the results of lm(), cor.test(), and all other tests, are R objects (usually lists) than can be used to retrieve the results or plot the values.\n\n\n\n#set par (we need to set up the par in every code chunk)\npar(mfrow = c(1, 2))\n#correlation plots with line\nplot(coli_genomes$contigs1kb ~ coli_genomes$Contigs, xlab=\"Contigs\", ylab=\"Contigs &gt; 1kb\")\nabline(modelito, col=\"red\")\n# we can include the lm() in the plot, without calculating it before\nplot(coli_genomes$contigs1kb ~ coli_genomes$average_contig, xlab=\"Average contig\", ylab=\"Contigs &gt; 1kb\")\nabline(lm(coli_genomes$contigs1kb ~ coli_genomes$average_contig), col=\"red\")\n\n\n\n#now we will check with a cor.test and add some text to the plot\n(test1 &lt;- cor.test(coli_genomes$contigs1kb, coli_genomes$Contigs))\n\n\n    Pearson's product-moment correlation\n\ndata:  coli_genomes$contigs1kb and coli_genomes$Contigs\nt = 7.651, df = 20, p-value = 2.306e-07\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.6945248 0.9420476\nsample estimates:\n     cor \n0.863334 \n\n(test2 &lt;- cor.test(coli_genomes$contigs1kb, coli_genomes$average_contig))\n\n\n    Pearson's product-moment correlation\n\ndata:  coli_genomes$contigs1kb and coli_genomes$average_contig\nt = -7.8453, df = 20, p-value = 1.574e-07\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n -0.9444427 -0.7055990\nsample estimates:\n       cor \n-0.8687624 \n\nstr(test1)\n\nList of 9\n $ statistic  : Named num 7.65\n  ..- attr(*, \"names\")= chr \"t\"\n $ parameter  : Named int 20\n  ..- attr(*, \"names\")= chr \"df\"\n $ p.value    : num 2.31e-07\n $ estimate   : Named num 0.863\n  ..- attr(*, \"names\")= chr \"cor\"\n $ null.value : Named num 0\n  ..- attr(*, \"names\")= chr \"correlation\"\n $ alternative: chr \"two.sided\"\n $ method     : chr \"Pearson's product-moment correlation\"\n $ data.name  : chr \"coli_genomes$contigs1kb and coli_genomes$Contigs\"\n $ conf.int   : num [1:2] 0.695 0.942\n  ..- attr(*, \"conf.level\")= num 0.95\n - attr(*, \"class\")= chr \"htest\"\n\n\n\nplot(coli_genomes$contigs1kb ~ coli_genomes$Contigs, xlab=\"Contigs\", ylab=\"Contigs &gt; 1kb\")\nabline(lm(coli_genomes$contigs1kb ~ coli_genomes$Contigs), col=\"red\")\n#now add the text in a defined position\ntext(200,200,paste(\"Pearson r2=\",round(test1$estimate,2)))\n\n\n\nplot(coli_genomes$contigs1kb ~ coli_genomes$average_contig, xlab=\"Average contig\", ylab=\"Contigs &gt; 1kb\")\nabline(lm(coli_genomes$contigs1kb ~ coli_genomes$average_contig), col=\"red\")\ntext(40000,200,paste(\"Pearson r2=\",round(test2$estimate,2)))\n\n\n\n\nIn a step further you can check multiple correlations in a single plot.\n\n#oh wait! why only one-vs-one?\nplot(coli_genomes[,c(\"VF\",\"Plasmids\",\"kmer\",\"Contigs\",\"N50\",\"longest.contig..bp.\",\"Assembly_length\",\"contigs1kb\",\"average_contig\")], main = \"Multiple Correlation plot\")\n\n\n\n\nNow, you have a quick info about possible variable correlations."
  },
  {
    "objectID": "r5.html#quick-exercise-i-1",
    "href": "r5.html#quick-exercise-i-1",
    "title": "R5: Base plots in R",
    "section": "",
    "text": "We are loading again the table described in Lesson 12 and we will try out some plots.\n\n#read data\nZFdata &lt;- read.csv(\"data/Zebrafish_data.csv\")\n\n#some plots\nbarplot(ZFdata)\n\nError in barplot.default(ZFdata): 'height' must be a vector or a matrix\n\nbarplot(ZFdata$pLoC)\n\n\n\npar(mfrow=c(1,3)) #arrange the three plots in a row \nbarplot(ZFdata$pLoC, col=\"red\", main=\"pLoc\")\nbarplot(ZFdata$EFNA3, col=\"green\", main=\"EFNA3\")\nbarplot(ZFdata$NC1s, col=\"blue\",main=\"NC1s\")\n\n\n\npar(mfrow=c(2,3)) #arrange the three plots in a row \nstripchart(ZFdata$pLoC, main=\"pLoc\")\nstripchart(ZFdata$pLoC, method=\"stack\", col=\"red\", main=\"pLoc\")\nstripchart(ZFdata$pLoC, method=\"overplot\", col=\"red\",  main=\"pLoc\")\nstripchart(ZFdata$pLoC, method=\"jitter\", col=\"red\", main=\"pLoc\")\nstripchart(ZFdata$EFNA3, method = \"stack\",col=\"green\", main=\"EFNA3\")\nstripchart(ZFdata$NC1s, method = \"stack\",col=\"blue\", main=\"N1cs\")\n\n\n\npar(mfrow=c(1,3)) #arrange the three plots in a row \nhist(ZFdata$pLoC, col=\"red\",  main=\"pLoc\")\nhist(ZFdata$EFNA3, col=\"green\", main=\"EFNA3\")\nhist(ZFdata$NC1s, col=\"blue\", main=\"N1cs\")\n\n\n\npar(mfrow=c(1,3)) #arrange the three plots in a row \nboxplot(ZFdata$pLoC, col=\"red\",  main=\"pLoc\")\nboxplot(ZFdata$EFNA3,  col=\"green\", main=\"EFNA3\")\nboxplot(ZFdata$NC1s, col=\"blue\", main=\"N1cs\")\n\n\n\n\nNow try to answer some questions about your data and obtained plots:\n\nWhich construct has the strongest impact on the disemination of metastatic cells?\nWhich plot represent best the data?\nDoes a barplot represent the same information than a boxplot?\n\nNow, we are going to represent the same data again.\n\n#we can save the par anytime, just in case \noldpar &lt;- par()\n#you can recall this settings with par(oldpar)\npar(mfrow = c(1, 3), cex.lab = 1, cex = 1, lwd = 2) #new settings\n\nhist(ZFdata$pLoC, col=rgb(1,0,0,0.5),  main=\"pLoc\", ylim = c(0,20), xlim = c(0,120), xlab = \"Number of Metastatic cells\")\nhist(ZFdata$EFNA3, col=rgb(0,1,0,0.5),  main=\"EFNA3\", ylim = c(0,20), xlim = c(0,120), xlab = \"Number of Metastatic cells\")\nhist(ZFdata$NC1s, col=rgb(0,0,1,0.5),  main=\"NC1s\", ylim = c(0,20), xlim = c(0,120), xlab = \"Number of Metastatic cells\")\n\n\n\nstripchart(ZFdata$pLoC, method=\"jitter\", pch=19, col=rgb(1,0,0,0.5), vertical=TRUE,  main=\"pLoc\", ylim = c(0,120), xlab = \"Number of Metastatic cells\")\nstripchart(ZFdata$EFNA3, method=\"jitter\", pch=19, col=rgb(0,1,0,0.5), vertical=TRUE, main=\"EFNA3\", ylim = c(0,120), xlab = \"Number of Metastatic cells\")\nstripchart(ZFdata$EFNA3, method=\"jitter\", pch=19, col=rgb(0,1,0,0.5), vertical=TRUE, main=\"EFNA3\", ylim = c(0,120), xlab = \"Number of Metastatic cells\")\n\n\n\nboxplot(ZFdata$pLoC, col=rgb(1,0,0,0.5),  ylim = c(0,120), xlab = \"Number of Metastatic cells\", main=\"pLoc\")\nboxplot(ZFdata$EFNA3, col=rgb(0,1,0,0.5), ylim = c(0,120), xlab = \"Number of Metastatic cells\",  main=\"EFNA3\")\nboxplot(ZFdata$NC1s, col=rgb(0,0,1,0.5), ylim = c(0,120), xlab = \"Number of Metastatic cells\", main=\"N1cs\")\n\n\n\npar(oldpar) #restore (optional)\n\nWarning in par(oldpar): graphical parameter \"cin\" cannot be set\n\n\nWarning in par(oldpar): graphical parameter \"cra\" cannot be set\n\n\nWarning in par(oldpar): graphical parameter \"csi\" cannot be set\n\n\nWarning in par(oldpar): graphical parameter \"cxy\" cannot be set\n\n\nWarning in par(oldpar): graphical parameter \"din\" cannot be set\n\n\nWarning in par(oldpar): graphical parameter \"page\" cannot be set\n\n#alternatively you can reset par with: par(no.readonly = TRUE) \n\nIn these plots above, you can see how plots can be deeply customized, and you can select colors (by name, RGB, hex or HSV code), size and shape of the points (cex and pch), plot and axis titles (main, xlab and ylab) and some tricks to avoid points overlapping (method = \"jitter\" or method=\"stacked\"). Also, we have used the function par() to arrange the plots integrated as a single plot. This is a very useful function that can be used to set or query many graphical parameters (see below). The arguments mfrow and mfcol are very useful to place graphs indicating the row and cols (or cols and row in mfcol). However, any other graph customization can be included here to avoid reapeat it during the plot.\nDo you think, you can answer better the questions now?\nBeyond some basic examples of plotting in R, the take-home message of this example is that the type of plot and the plot parameters (in this case the scale) can be essential for correct interpretation of the data and if they are not properly adjusted the plot can be strongly misleading.\nFurther, to compare three conditions, we needed to make three independent plots. However, in the table, there are actually six conditions, and it is easy to imagine a table with more conditions. How could you plot that? Here is where the generation of a datamatrix table, as shown in Lesson 12 is very important.\n\nZF_stacked &lt;- stack(ZFdata)\n\nboxplot(ZF_stacked$values ~ ZF_stacked$ind,  col=c(rgb(1,0,0,0.5),rgb(0,1,0,0.5),rgb(0,0,1,0.5),rgb(1,0.5,0,0.5),rgb(0.5,0.5,0.5,0.5),rgb(0,1,1,0.5)))\ncolorines=c(rgb(1,0,0,0.5),rgb(0,1,0,0.5),rgb(0,0,1,0.5),rgb(1,0.5,0,0.5),rgb(0.5,0.5,0.5,0.5),rgb(0,1,1,0.5)) #define the colors for the whole analysis\nboxplot(ZF_stacked$values ~ ZF_stacked$ind,  col=colorines)\n\n\n\nstripchart(ZF_stacked$values ~ ZF_stacked$ind, vertical = TRUE, method=\"jitter\", col=colorines, pch=19, cex=1, ylab=\"Number of cells\", xlab=\"Plasmid\")\n\n\n\n#what about barplot?\nmeans &lt;- aggregate(values ~ ind, data=ZF_stacked, mean) #you can use by() or tapply()\nbarplot(means$values, ylim=c(0,120), col=colorines, ylab=\"Number of cells\", xlab=\"Plasmid\")\n\n\n\n\nThe stripchart and the boxplot strongly suggest that NC2s is probably the strongest transcript, but that is not shown in the barplot. These plots clearly show that barplots are intended for single values (categorical data) and can mislead your conclusions."
  },
  {
    "objectID": "r5.html#quick-exercise-ii",
    "href": "r5.html#quick-exercise-ii",
    "title": "R5: Base plots in R",
    "section": "",
    "text": "For this exercise we are going to use a dataset called zebrafish_data.csv. This file contains the results of an experiment in which a collaborator scored the number of metastatic cancer cells upon the expression of different transcripts of the EFNA3 gene. Each transcript is cloned into a pLoC plasmid, and we have negative (empty plasmid) and positive controls (wt EFNA3 transcript), as well as four transcript mutants. Let’s import and check the data.\n\n#read data\nZFdata &lt;- read.csv(\"data/Zebrafish_data.csv\")\nstr(ZFdata)\n\n'data.frame':   41 obs. of  6 variables:\n $ pLoC : int  36 32 10 26 15 23 17 14 44 12 ...\n $ EFNA3: int  35 33 17 25 89 36 40 36 35 37 ...\n $ NC1  : int  58 26 26 18 20 24 10 31 28 26 ...\n $ NC1s : int  11 11 19 12 12 20 7 104 116 11 ...\n $ NC2  : int  53 37 56 48 27 29 22 79 22 18 ...\n $ NC2s : int  40 43 19 18 33 29 29 25 28 47 ...\n\n\nHow would you construct barplots of the data from the six experimental conditions?\n\n hist(ZFdata) barplot(ZFdata) barplot(ZFdata$pLoC), and the same for each construct hist(ZFdata$pLoC), and the same for each construct\n\nLet’s see some examples:\n\n#some plots\nbarplot(ZFdata)\n\nError in barplot.default(ZFdata): 'height' must be a vector or a matrix\n\nbarplot(ZFdata$pLoC)\n\n\n\npar(mfrow=c(1,3)) #arrange the three plots in a row \n#we include a plot title with \"main\"\nbarplot(ZFdata$pLoC, col=\"red\", main=\"pLoc\")\nbarplot(ZFdata$EFNA3, col=\"green\", main=\"EFNA3\")\nbarplot(ZFdata$NC1s, col=\"blue\",main=\"NC1s\")\n\n\n\npar(mfrow=c(2,3)) #arrange the six plots in two rows\n#note the \"method\" option\nstripchart(ZFdata$pLoC, main=\"pLoc\")\nstripchart(ZFdata$pLoC, method=\"stack\", col=\"red\", main=\"pLoc\")\nstripchart(ZFdata$pLoC, method=\"overplot\", col=\"red\",  main=\"pLoc\")\nstripchart(ZFdata$pLoC, method=\"jitter\", col=\"red\", main=\"pLoc\")\nstripchart(ZFdata$EFNA3, method = \"stack\",col=\"green\", main=\"EFNA3\")\nstripchart(ZFdata$NC1s, method = \"stack\",col=\"blue\", main=\"N1cs\")\n\n\n\n#now histograms\npar(mfrow=c(1,3)) #arrange the three plots in a row \nhist(ZFdata$pLoC, col=\"red\",  main=\"pLoc\")\nhist(ZFdata$EFNA3, col=\"green\", main=\"EFNA3\")\nhist(ZFdata$NC1s, col=\"blue\", main=\"N1cs\")\n\n\n\n\nNow try to answer some questions about your data and obtained plots:\n1. Which construct has the strongest impact on the dissemination of metastatic cells?\n\n The empty plasmid pLoC WT EFNA3 NC1 NC1s NC2 NC2s I cannot say\n\n2. Which plot represent best these data?\n\n Histogram Barplot Boxplot Stripchart I am not sure\n\n3. Does a boxplot represent the same information than a histogram?\n\n No, not at all Yes, they are the same Yes, but a boxplot will show best the differences between my samples Yes, but a histogram will show best the differences between my samples\n\n4. Does a barplot represent the same information than a boxplot?\n\n No, a barplot represents data frequencies/distribution No, boxplots and histograms represent data frequencies/distribution Yes, they alike\n\nNow, we are going to represent the same data again, introducing some more customization\n\n\n\n\n\n\n\n\n\n\n\nCan you reproduce the above plots?\n\n\n\nAnswer\n\n#new par settings\npar(mfrow = c(1, 3), cex.lab = 1, cex = 1, lwd = 2)\n#plotting\nhist(ZFdata$pLoC, col=rgb(1,0,0,0.5),  main=\"pLoc\", ylim = c(0,20), xlim = c(0,120), xlab = \"Number of Metastatic cells\")\nhist(ZFdata$EFNA3, col=rgb(0,1,0,0.5),  main=\"EFNA3\", ylim = c(0,20), xlim = c(0,120), xlab = \"Number of Metastatic cells\")\nhist(ZFdata$NC1s, col=rgb(0,0,1,0.5),  main=\"NC1s\", ylim = c(0,20), xlim = c(0,120), xlab = \"Number of Metastatic cells\")\n\nstripchart(ZFdata$pLoC, method=\"jitter\", pch=19, col=rgb(1,0,0,0.5), vertical=TRUE,  main=\"pLoc\", ylim = c(0,120), xlab = \"Number of Metastatic cells\")\nstripchart(ZFdata$EFNA3, method=\"jitter\", pch=19, col=rgb(0,1,0,0.5), vertical=TRUE, main=\"EFNA3\", ylim = c(0,120), xlab = \"Number of Metastatic cells\")\nstripchart(ZFdata$EFNA3, method=\"jitter\", pch=19, col=rgb(0,1,0,0.5), vertical=TRUE, main=\"EFNA3\", ylim = c(0,120), xlab = \"Number of Metastatic cells\")\n\nboxplot(ZFdata$pLoC, col=rgb(1,0,0,0.5),  ylim = c(0,120), xlab = \"Number of Metastatic cells\", main=\"pLoc\")\nboxplot(ZFdata$EFNA3, col=rgb(0,1,0,0.5), ylim = c(0,120), xlab = \"Number of Metastatic cells\",  main=\"EFNA3\")\nboxplot(ZFdata$NC1s, col=rgb(0,0,1,0.5), ylim = c(0,120), xlab = \"Number of Metastatic cells\", main=\"N1cs\")\n\n\nDo you think, you can answer better the questions now?\nBeyond some basic examples of plotting in R, the take-home message of this example is that the type of plot and the plot parameters (in this case the scale) can be essential for correct interpretation of the data and if they are not properly adjusted the plot can be strongly misleading.\nThe stripchart and the boxplot strongly suggest that NC2s is probably the strongest transcript, but that is not shown in the barplot. These plots clearly show that barplots are intended for single values (categorical data) and can mislead your conclusions."
  },
  {
    "objectID": "r5.html#plot-grouped-data",
    "href": "r5.html#plot-grouped-data",
    "title": "R5: Base plots in R",
    "section": "",
    "text": "We will still use the data from the zebrafish experiment here\nIn the previous plots, in order to compare three conditions, we needed to make three independent plots. However, in the table, there are six conditions, and it is not very difficult to imagine experiments that might result in a table with even more conditions. How could you plot that? The key question is, different conditions means different variables? In other words:\nHow many variables are there in the Zebrafish dataset?\n\n 3 variables, WT, empty plasmid and 4 mutants 6, one for each expressed transcript 2 variables, the (1) plasmid/expressed transcript and (2) the number of metastatic cells\n\nIn data analysis (check Lesson R6), particularly when you want to compare many variables in different groups, it is more handy to create a stacked table or datamatrix. Stacked table are also often referred to as narrow tables. In contrast, the tables with different conditions (of a same variable) in different columns are named wide table or unstacked. The code below shows how to stack and plot your data by groups using the function stack().\n\nZF_stacked &lt;- stack(ZFdata)\n\n#you can also define a colors vector that can be reused\ncolorines=c(rgb(1,0,0,0.5),rgb(0,1,0,0.5),rgb(0,0,1,0.5),rgb(1,0.5,0,0.5),rgb(0.5,0.5,0.5,0.5),rgb(0,1,1,0.5)) \nboxplot(ZF_stacked$values ~ ZF_stacked$ind,  col=colorines)\n\n\n\nstripchart(ZF_stacked$values ~ ZF_stacked$ind, vertical = TRUE, method=\"jitter\", col=colorines, pch=19, cex=1, ylab=\"Number of cells\", xlab=\"Plasmid\")"
  },
  {
    "objectID": "r5.html#quick-exercise-iii",
    "href": "r5.html#quick-exercise-iii",
    "title": "R5: Base plots in R",
    "section": "",
    "text": "Now let’s think again in our E. coli genomes. How would you add more layers of information to the plot, like labels of specific points?\n\n\n\n\n\n\n\n\nAnswer\n\n#point label, but only some \"selected\" points\n\n#step1: create a vector with the selection\nselected &lt;- c(7, 17, 18)\n#step2: make a plot\nplot(coli_genomes$contigs1kb ~ coli_genomes$Contigs, pch=19,col=rgb(1,0,0,0.5), xlab=\"Contigs\", ylab=\"Contigs &gt; 1kb\")\n\n#step 3: add the labels as a text layer\n#note that you can use the formula for the text coordinates\ntext(coli_genomes$contigs1kb[selected] ~ coli_genomes$Contigs[selected],\n     labels = coli_genomes$Strain[selected],\n     cex = 0.6, pos = 4, col = \"red\")\n\n\nYou can look for more custom options because there are a lot. I also suggest looking at the identify() function, which allows the quick interactive identification and labeling of selected points.\nNow, we repeat the scatterplot above of contigs1kb vs. Contigs, but instead of labels, coloring the points by Source as in the plot below. Finally, use the function legend() to add a legend.\n\n\n\n\n\n\n\n\nHint\n\n#Think in a way to use the variable 'Source' and conditionally recode it as colors\n#Then, a recursive way will help you to generate a vector to color all the elements in the plot\n\n\n\n\n\nAnswer\n\n#recode the source as color\n#step 1: define an empty vector (not required here, but better to do it)\ncolorines &lt;- c()\n#step 2: use a loop to run over all the source vector\nfor (i in 1:nrow(coli_genomes)){\n#step 3: use switch() to recode the sources as colors\n#note that Source is a factor but we need to treat it as a character here\n  colorines[i] &lt;- switch(as.character(coli_genomes$Source[i]),\n      Avian=rgb(1,0,0,0.4),\n      Human=rgb(0,1,0,0.4),\n      Porcine=rgb(0,0,1,0.4))                   \n}\n#plot\nplot(coli_genomes$contigs1kb ~ coli_genomes$Contigs, pch=21,bg=colorines, xlab=\"Contigs\", ylab=\"Contigs &gt; 1kb\")\n\n#legend\n#the function unique() is important here, can you figure out why?\nlegend(100,200,legend=unique(coli_genomes$Source),fill=unique(colorines))"
  },
  {
    "objectID": "r5.html#why-do-we-make-plots",
    "href": "r5.html#why-do-we-make-plots",
    "title": "R5: Base plots in R",
    "section": "",
    "text": "Data visualization is a very important part of a data analysis because they can efficiently summarize large amounts of data in a graphical format and reveal new insights that are difficult to understand from the raw data. From a researcher’s or data analyst’s perspective, plotting datasets also helps you become familiar with the data and plan next steps in your analysis. It also allows you to identify statistical pitfalls with an initial plot.\n\n\n\n\n\n\nAnscombe’s quartet. Each of the four datasets consists of 11 data points (orange points) and have nearly identical statistical properties, including means, sample variances, Pearson’s sample correlation (r), and linear regression line (blue lines). Modified from Anscombe FJ. Graphs in statistical analysis. Am Stat 1973;27:17–21\n\n\nThis well-known quartet highlights the importance of graphing data prior to analysis, and why statistical reviewers often ask for such graphs to be made available. Check out also the Dinosaurus example in the reference 2 below."
  },
  {
    "objectID": "r5.html#which-plot-should-i-do-with-my-data",
    "href": "r5.html#which-plot-should-i-do-with-my-data",
    "title": "R5: Base plots in R",
    "section": "",
    "text": "There are many different types of graphs, each with their own strengths and use cases. One of the trickiest parts of the analysis process is choosing the right way to represent your data with one of these visualizations. The wrong chart can lead to confusion or misinterpretation of the data (see some examples of bad charts here).\nFrom a classical data analysis perspective, the first consideration in choosing the right plot is the nature of your variables. Some charts are recommended for numerical data (quantitative variables) and others for categorical data (qualitative variables). Then you should consider what role you want your data visualization to play, i.e., what question you want to answer or what message you want to convey. This depends on the number of variables as well as their distribution, grouping or correlation. There are some best practice guidelines, but ultimately you need to consider what is best for your data. What do you want to show? What chart best conveys your message? Is it a comparison between groups? Is it a frequency distribution of 1 variable?\nfor a guidance, you can use the Chartchooser below, by Andrew Abela.\n\n\n\nThe ExtremePresentation method for choosing a plot or chart.\n\n\nYou can see a description of some of the most common plot types, with many examples on books and dedicated R websites. I suggest to take a look to some of the suggested References below, or some quick examples, like those here or here. Rather than going through a wide list of plots, we are going to use some examples to learn some basic plotting and see the effect of plot selection in order to understand your data and use them to answer questions."
  },
  {
    "objectID": "r1.html",
    "href": "r1.html",
    "title": "R1: Variables, Operators and data structures",
    "section": "",
    "text": "In programming, a variable is a symbolic name or identifier that represents a storage location in the computer’s memory. Thus, variables provide a means to access (and manipulate) data stored in the computer’s memory from within the program. In practice a variable acts as a container for storing data or values.\nData Objects. In R, data objects1 are the fundamental entities that hold data or information. They are the variables or entities that you create and manipulate in your R code. Data objects can include vectors, matrices, data frames, lists, etc. Essentially, anything that can store data or represent information in R is considered a data object. data Objects are of course stored in the computer’s memory, hence they are referenced and manipulated using variables.\nData Types. Data types in R refer to the specific classification or categorization of the values that can be stored in data objects. R has several basic data types, also known as atomic data types2. These data types represent different kinds of data, such as logical (boolean), numeric (double and integer), complex, character, and raw. Each data type has its own set of operations and behaviors associated with it. For example, logical data types can take values of TRUE, FALSE, and NA (representing missing values), while numeric data types can store numerical values.\nIn R, variables can hold different data types without the need to declare them in advance. Values are assigned to variables using the assignment operator &lt;-. The symbol = can also be used, but it is not standard syntax and not recommended.\nVariable names may contain dots and underscores but cannot begin with a number (or underscore).\nIn R, the class of a variable refers to the specific type or category of the object that the variable represents. It provides information about how the object is handled by R’s internal functions and methods. Classes in R are typically associated with specific data structures or types. For example, a variable can have a class such as “numeric” if it represents a numeric data type, “character” if it represents a character string, “data.frame” if it represents a data frame, and so on. The class of a variable is important because it influences how R treats the object and determines which functions or methods can be applied to it. Different classes have different behaviors and may have specific functions or methods associated with them.\nFinally, in R, NA, NaN, and NULL are special values used to represent specific situations or indicate missing or undefined data:\n\nNA: NA stands for “Not Available” or “Missing Value”. It is used to represent missing or undefined values in R. The value NA belong to different data types, such as logical, numeric, character, etc. For example, if a value is missing in a numeric vector, it can be represented as NA. NA values are often ignored or excluded from computations or operations unless explicitly handled.\nNaN: NaN stands for “Not a Number”. It is a special value used to represent undefined or unrepresentable results of arithmetic operations that do not yield a numeric value. NaN is typically encountered when performing calculations that involve undefined operations, such as dividing zero by zero or taking the square root of a negative number.\nNULL: NULL is a special object in R that represents the absence of a value or an empty object. It is often used to indicate the absence of a valid object or as a placeholder. NULL is different from NA, as it represents the absence of any value or object altogether.\n\n\nA_Number &lt;- 53\nA_Number\n\n[1] 53\n\nA_Text &lt;- \"R rocks!\"\nA_Text\n\n[1] \"R rocks!\"\n\nA_Logical &lt;- TRUE  #one of the possible values of a boolean data type\nA_Logical\n\n[1] TRUE\n\nA_Logical &lt;- true\n\nError in eval(expr, envir, enclos): object 'true' not found\n\nA_NA &lt;- NA\nA_NA\n\n[1] NA\n\nA_NA &lt;- na\n\nError in eval(expr, envir, enclos): object 'na' not found\n\n\nTo summarize, variables are used refer to specific data objects that are the containers or entities that hold data. The data types specify the kind of values that can be stored within data objects. Data types determine how the data is interpreted and how operations are performed on the data objects."
  },
  {
    "objectID": "r1.html#vectors",
    "href": "r1.html#vectors",
    "title": "R1: Variables, Operators and data structures",
    "section": "4.1 Vectors",
    "text": "4.1 Vectors\nA vector is a (one dimensional) collection of elements, all of the same type. Vectors play an essential role in R, so much that R can be considered a vectorized language. That means that operations are applied to each element of the vector automatically, without the need to loop through the elements of the vector as it would be necessary in almost any other language such a python. The most common way to generate a vector is using the combine or concatenate function c() providing the list of elements separated by commas. We can accessing individual elements of the vector using brackets and the index of the elements.\n\n\n\n\n\n\nWarning\n\n\n\nVectors are indexed starting from 1 instead of 0, following a 1-based indexing convention. This means that the first element of a vector is accessed using the index 1, not 0 as in some other programming languages such as python.\n\n\n\nv1 &lt;- c(1, 11:13)  #the concatenate function creates a vector out of the values\nclass(v1)\n\n[1] \"numeric\"\n\nis.numeric(v1)\n\n[1] TRUE\n\nv4 &lt;- as.character(v1)  #change the data type of the elements in v1\nv4\n\n[1] \"1\"  \"11\" \"12\" \"13\"\n\nv5 &lt;- c(1, 3, 27)\nv5[1]  #elements are retrieved by using square brackets and the index of the element\n\n[1] 1\n\nv5[0]  #Warning! first element is index 1\n\nnumeric(0)\n\n# we can 'add' labels (names) to the elements of a vector\nnames(v5)\n\nNULL\n\nnames(v5) &lt;- c(\"PHY\", \"BIO\", \"BQ\")\nv5\n\nPHY BIO  BQ \n  1   3  27 \n\nnames(v5)\n\n[1] \"PHY\" \"BIO\" \"BQ\" \n\nv5[\"BIO\"]  # then, we can retrieve elements by their label\n\nBIO \n  3 \n\nsum(v5)\n\n[1] 31\n\nv6 &lt;- c(\"PHY\", \"BIO\", \"BQ\")\n# cheching the presence of an element in a vector\n\"BQ\" %in% v6\n\n[1] TRUE\n\n\"BQ\" %in% v5\n\n[1] FALSE\n\n\"BQ\" %in% names(v5)\n\n[1] TRUE\n\n\"PHY\" %in% \"BIOPHYSICS\"  #Warning: it does NOT checks for substrings in strings\n\n[1] FALSE\n\nnames(v5) == \"BIO\"\n\n[1] FALSE  TRUE FALSE\n\nwhich(names(v5) == \"BIO\")  #returns the index(es) of the elements matching the comparison\n\n[1] 2\n\n\n\n4.1.1 Generation of vectors of periodic sequences\nR has a number of facilities for generating commonly used sequences of numbers or characters. The most common are the colon operator :, function seq() and function rep(). See the next examples:\n\n2:7\n\n[1] 2 3 4 5 6 7\n\n7:2\n\n[1] 7 6 5 4 3 2\n\nletters[10:13]\n\n[1] \"j\" \"k\" \"l\" \"m\"\n\nLETTERS[20:17]\n\n[1] \"T\" \"S\" \"R\" \"Q\"\n\nseq(2, 7)\n\n[1] 2 3 4 5 6 7\n\nseq(from = 2, to = 9, by = 0.5)\n\n [1] 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0 8.5 9.0\n\nseq(from = -5, length = 20, by = 0.2)\n\n [1] -5.0 -4.8 -4.6 -4.4 -4.2 -4.0 -3.8 -3.6 -3.4 -3.2 -3.0 -2.8 -2.6 -2.4 -2.2\n[16] -2.0 -1.8 -1.6 -1.4 -1.2\n\nrep(c(\"A\", \"B\", \"C\"), times = 3)\n\n[1] \"A\" \"B\" \"C\" \"A\" \"B\" \"C\" \"A\" \"B\" \"C\"\n\nrep(c(\"A\", \"B\", \"C\"), each = 3)\n\n[1] \"A\" \"A\" \"A\" \"B\" \"B\" \"B\" \"C\" \"C\" \"C\"\n\nrep(c(\"A\", \"B\", \"C\"), c(2, 3, 0))\n\n[1] \"A\" \"A\" \"B\" \"B\" \"B\"\n\nz &lt;- c(2, 1, 3, 4, 9, 6, -1)\nsort(z)\n\n[1] -1  1  2  3  4  6  9\n\norder(z)\n\n[1] 7 2 1 3 4 6 5\n\nz[order(z)]\n\n[1] -1  1  2  3  4  6  9\n\nrange(z)\n\n[1] -1  9\n\n\nNote that function order() returns of the element in the current vector sorted according to the value of the element. In the example above the smallest number is -1 that occupies position 7 (index 7) in the vector. Thus, the first element in the output of function order() is 7. The second smaller is number 1, that occupies position the second position in the original vector(index 2), thus the second element in the output of the function is 2 and so on."
  },
  {
    "objectID": "r1.html#generation-of-vectors-of-periodic-sequences",
    "href": "r1.html#generation-of-vectors-of-periodic-sequences",
    "title": "R1: Variables, Operators and data structures",
    "section": "4.2 Generation of vectors of periodic sequences",
    "text": "4.2 Generation of vectors of periodic sequences\nR has a number of facilities for generating commonly used sequences of numbers or characters. The most common are the colon operator :, function seq() and function rep(). See the next examples:\n\n2:7\n\n[1] 2 3 4 5 6 7\n\n7:2\n\n[1] 7 6 5 4 3 2\n\nletters[10:13]\n\n[1] \"j\" \"k\" \"l\" \"m\"\n\nLETTERS[20:17]\n\n[1] \"T\" \"S\" \"R\" \"Q\"\n\nseq(2, 7)\n\n[1] 2 3 4 5 6 7\n\nseq(from = 2, to = 9, by = 0.5)\n\n [1] 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0 8.5 9.0\n\nseq(from = -5, length = 20, by = 0.2)\n\n [1] -5.0 -4.8 -4.6 -4.4 -4.2 -4.0 -3.8 -3.6 -3.4 -3.2 -3.0 -2.8 -2.6 -2.4 -2.2\n[16] -2.0 -1.8 -1.6 -1.4 -1.2\n\nrep(c(\"A\", \"B\", \"C\"), times = 3)\n\n[1] \"A\" \"B\" \"C\" \"A\" \"B\" \"C\" \"A\" \"B\" \"C\"\n\nrep(c(\"A\", \"B\", \"C\"), each = 3)\n\n[1] \"A\" \"A\" \"A\" \"B\" \"B\" \"B\" \"C\" \"C\" \"C\"\n\nrep(c(\"A\", \"B\", \"C\"), c(2, 3, 0))\n\n[1] \"A\" \"A\" \"B\" \"B\" \"B\"\n\nz &lt;- c(2, 1, 3, 4, 9, 6, -1)\nsort(z)\n\n[1] -1  1  2  3  4  6  9\n\norder(z)\n\n[1] 7 2 1 3 4 6 5\n\nz[order(z)]\n\n[1] -1  1  2  3  4  6  9\n\nrange(z)\n\n[1] -1  9\n\n\nNote that function order() returns of the element in the current vector sorted according to the value of the element. In the example above the smallest number is -1 that occupies position 7 (index 7) in the vector. Thus, the first element in the output of function order() is 7. The second smaller is number 1, that occupies position the second position in the original vector(index 2), thus the second element in the output of the function is 2 and so on."
  },
  {
    "objectID": "r1.html#footnotes",
    "href": "r1.html#footnotes",
    "title": "R1: Variables, Operators and data structures",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nEverything in R is an object (constants, data structures, functions, graphs, etc.). Objects have a mode that describes how the object is stored and a class that describes how the object is handled by functions. The mode corresponds to what is called a class in other languages. Additionally, objects belong to a type, which basically coincides with the mode.↩︎\nNote that in R, atomic types are always stored as vectors, even when there is a single element.↩︎"
  },
  {
    "objectID": "r2.html",
    "href": "r2.html",
    "title": "R2: Flow Control",
    "section": "",
    "text": "Sequential execution of programming commands is insufficient for solving anything beyond trivial tasks. In most cases, solving a problem programmatically involves executing specific statements only under certain conditions and/or repeating a statement or set of statements multiple times. This ability to control when and how many times a statement or set of statements is executed is referred to as Flow control. In R, flow control is achieved using two specific structures in our code: - Conditional structures: These structures allow the execution of a statement or set of statements based on a condition. - Loop structures: These structures allow the execution of a statement or set of statements for a fixed number of times or until a condition is met. In both cases, the block of code containing the statements to be conditionally or repeatedly executed is delimited by curly brackets."
  },
  {
    "objectID": "r1.html#factors",
    "href": "r1.html#factors",
    "title": "R1: Variables, Operators and data structures",
    "section": "4.2 Factors",
    "text": "4.2 Factors\nFactors are used to record categorical (a.k.a nominal) variables. The function factor() takes a vector and identifies all the different values present in it, then each value is assumed to be a different category or level. The levels represent the distinct categories or groups that the variable can take on.\n\n# the following vectors represent the initial and final\n# weight of 15 individuals\nW.initial &lt;- c(55, 65, 70, 93, 71, 50, 61, 80, 81, 60, 43, 77,\n    78, 65, 100)  #initial weight\nW.final &lt;- c(52, 66, 71, 92, 61, 51, 55, 81, 70, 52, 44, 78,\n    77, 60, 90)  #final weight\n# the following character vector represent the treatment\n# received by each individual\nTxt &lt;- c(\"D3\", \"D2\", \"D3\", \"D3\", \"D1\", \"D3\", \"D2\", \"D2\", \"D2\",\n    \"D1\", \"D3\", \"D2\", \"D2\", \"D1\", \"D1\")  #Treatment\nTxt\n\n [1] \"D3\" \"D2\" \"D3\" \"D3\" \"D1\" \"D3\" \"D2\" \"D2\" \"D2\" \"D1\" \"D3\" \"D2\" \"D2\" \"D1\" \"D1\"\n\nclass(Txt)\n\n[1] \"character\"\n\nTxt &lt;- as.factor(Txt)  #Transforms character vector Txt into a factor\nTxt\n\n [1] D3 D2 D3 D3 D1 D3 D2 D2 D2 D1 D3 D2 D2 D1 D1\nLevels: D1 D2 D3\n\ntable(Txt)\n\nTxt\nD1 D2 D3 \n 4  6  5 \n\nWeight.gain &lt;- W.final - W.initial  #calculates weight gain\nWeight.gain\n\n [1]  -3   1   1  -1 -10   1  -6   1 -11  -8   1   1  -1  -5 -10\n\nwhich(Txt == \"D1\")  #index of the individuals who received treatment D1\n\n[1]  5 10 14 15\n\nWeight.gain[which(Txt == \"D2\")]  #Weigh gain of individuals who received treatment D1\n\n[1]   1  -6   1 -11   1  -1\n\nmean(Weight.gain[which(Txt == \"D3\")])  # mean Weigh gain of individuals who received treatment D3\n\n[1] -0.2\n\nby(data = Weight.gain, INDICES = Txt, FUN = mean)  #calculates weight gain mean for each treatment group\n\nTxt: D1\n[1] -8.25\n------------------------------------------------------------ \nTxt: D2\n[1] -2.5\n------------------------------------------------------------ \nTxt: D3\n[1] -0.2"
  },
  {
    "objectID": "r1.html#matrices-and-arrays",
    "href": "r1.html#matrices-and-arrays",
    "title": "R1: Variables, Operators and data structures",
    "section": "4.3 Matrices and arrays",
    "text": "4.3 Matrices and arrays\nA matrix is a two-dimensional data structure that consists of rows and columns. It is used to store data elements of the same data type arranged in a rectangular grid-like structure. To retrieve a single element, specify the row and column indices within square brackets. An array is a multi-dimensional data structure that extends the concept of matrices to more than two dimensions. It can store elements of the same data type in a grid-like structure with multiple dimensions.\n\nMyVector &lt;- 1:9\nMyVector\n\n[1] 1 2 3 4 5 6 7 8 9\n\nMyMatrix &lt;- matrix(MyVector, ncol = 3)  #geneates a 3 colunm matrix with elements from MyVector \nMyMatrix\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\ndim(Matrix)  #number of rows and columns\n\nError in eval(expr, envir, enclos): object 'Matrix' not found\n\n# accessing individual elements:\nMyMatrix[2, ]\n\n[1] 2 5 8\n\nMyMatrix[, 3]\n\n[1] 7 8 9\n\nMyMatrix[3, 2]\n\n[1] 6\n\n# accessing several elements:\nMyMatrix[2:3, 1:2]\n\n     [,1] [,2]\n[1,]    2    5\n[2,]    3    6\n\n# basic aritmetic operations:\nMyMatrix * 2\n\n     [,1] [,2] [,3]\n[1,]    2    8   14\n[2,]    4   10   16\n[3,]    6   12   18\n\nMyMatrix + 5\n\n     [,1] [,2] [,3]\n[1,]    6    9   12\n[2,]    7   10   13\n[3,]    8   11   14\n\nt(MyMatrix)  #flips a matrix over its main diagonal (transposition)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\nMyVector2 &lt;- 1:12\nMyArray &lt;- array(MyVector2, dim = c(2, 2, 3))  #geneates a 2x2x3 array with elements from MyVector2 :\n# accessing individual elements\nMyArray[, , 2]\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8"
  },
  {
    "objectID": "r1.html#data-frames",
    "href": "r1.html#data-frames",
    "title": "R1: Variables, Operators and data structures",
    "section": "4.4 Data frames",
    "text": "4.4 Data frames\nData frames are two-dimensional tabular data structures where each column is a vector. Unlike matrices, data frames allow columns of different data types within the same structure. This flexibility allows you to handle mixed or heterogeneous data, such as storing numeric measurements, categorical variables, dates, and more within a single data frame. Data frames are created with the data.frame() function and the elements can be retrieved with the square bracket notation specifying the row and column indexes, as we saw for matrices. In addition, column vectors can be retrieved using the $ operator (list-subset operator).\n\n# see @factors-code above\nW.initial &lt;- c(55, 65, 70, 93, 71, 50, 61, 80, 81, 60, 43, 77,\n    78, 65, 100)\nW.final &lt;- c(52, 66, 71, 92, 61, 51, 55, 81, 70, 52, 44, 78,\n    77, 60, 90)\nTxt &lt;- c(\"D3\", \"D2\", \"D3\", \"D3\", \"D1\", \"D3\", \"D2\", \"D2\", \"D2\",\n    \"D1\", \"D3\", \"D2\", \"D2\", \"D1\", \"D1\")\nDietDrugs &lt;- data.frame(W.initial, W.final, Txt)  #creates a data frame with 3 columns\nDietDrugs\n\n   W.initial W.final Txt\n1         55      52  D3\n2         65      66  D2\n3         70      71  D3\n4         93      92  D3\n5         71      61  D1\n6         50      51  D3\n7         61      55  D2\n8         80      81  D2\n9         81      70  D2\n10        60      52  D1\n11        43      44  D3\n12        77      78  D2\n13        78      77  D2\n14        65      60  D1\n15       100      90  D1\n\ndim(DietDrugs)\n\n[1] 15  3\n\n# Accessing elements:\nDietDrugs[, 2]\n\n [1] 52 66 71 92 61 51 55 81 70 52 44 78 77 60 90\n\nDietDrugs[1, ]\n\n  W.initial W.final Txt\n1        55      52  D3\n\nDietDrugs[3, 1]\n\n[1] 70\n\nDietDrugs$Txt\n\n [1] \"D3\" \"D2\" \"D3\" \"D3\" \"D1\" \"D3\" \"D2\" \"D2\" \"D2\" \"D1\" \"D3\" \"D2\" \"D2\" \"D1\" \"D1\"\n\nDietDrugs$Txt[3]\n\n[1] \"D3\"\n\nDietDrugs[which(DietDrugs$Txt == \"D1\"), ]\n\n   W.initial W.final Txt\n5         71      61  D1\n10        60      52  D1\n14        65      60  D1\n15       100      90  D1\n\n# view the top or bottom rows of a data frame:\nhead(DietDrugs)\n\n  W.initial W.final Txt\n1        55      52  D3\n2        65      66  D2\n3        70      71  D3\n4        93      92  D3\n5        71      61  D1\n6        50      51  D3\n\ntail(DietDrugs)\n\n   W.initial W.final Txt\n10        60      52  D1\n11        43      44  D3\n12        77      78  D2\n13        78      77  D2\n14        65      60  D1\n15       100      90  D1\n\n# add row names\nPatients &lt;- paste(\"Patient\", 1:15, sep = \"\")\nrownames(DietDrugs) &lt;- Patients\n# add new columns (method #1):\nDietDrugs$W.gain &lt;- DietDrugs$W.final - DietDrugs$W.initial\nDietDrugs\n\n          W.initial W.final Txt W.gain\nPatient1         55      52  D3     -3\nPatient2         65      66  D2      1\nPatient3         70      71  D3      1\nPatient4         93      92  D3     -1\nPatient5         71      61  D1    -10\nPatient6         50      51  D3      1\nPatient7         61      55  D2     -6\nPatient8         80      81  D2      1\nPatient9         81      70  D2    -11\nPatient10        60      52  D1     -8\nPatient11        43      44  D3      1\nPatient12        77      78  D2      1\nPatient13        78      77  D2     -1\nPatient14        65      60  D1     -5\nPatient15       100      90  D1    -10\n\n# add new columns (method #2):\nW.foldchange &lt;- round(DietDrugs$W.final/DietDrugs$W.initial,\n    2)\nDietDrugs &lt;- cbind(DietDrugs, W.foldchange)\nDietDrugs\n\n          W.initial W.final Txt W.gain W.foldchange\nPatient1         55      52  D3     -3         0.95\nPatient2         65      66  D2      1         1.02\nPatient3         70      71  D3      1         1.01\nPatient4         93      92  D3     -1         0.99\nPatient5         71      61  D1    -10         0.86\nPatient6         50      51  D3      1         1.02\nPatient7         61      55  D2     -6         0.90\nPatient8         80      81  D2      1         1.01\nPatient9         81      70  D2    -11         0.86\nPatient10        60      52  D1     -8         0.87\nPatient11        43      44  D3      1         1.02\nPatient12        77      78  D2      1         1.01\nPatient13        78      77  D2     -1         0.99\nPatient14        65      60  D1     -5         0.92\nPatient15       100      90  D1    -10         0.90"
  },
  {
    "objectID": "r1.html#lists",
    "href": "r1.html#lists",
    "title": "R1: Variables, Operators and data structures",
    "section": "4.5 Lists",
    "text": "4.5 Lists\nA list is a data structure consisting of an ordered collection of (potentially different) objects. They are constructed using the function list(). The elements (a.k.a components) in a list are numbered and can be accessed using a double bracket notation and the index of the component. Oftentimes, the elements in a list are also named. In this case, the components can be accessed using the double square bracket and the name of the item instead of its index. Additionally names components can be retrieved using the $ operator (list-subset operator).\n\n# A list of students recording different features notice\n# that each element can be a different type of object or\n# data structure\nStudents &lt;- list(Names = c(\"Ana\", \"Juan\", \"Mar\"), Age = c(20,\n    20, 21), Sex = factor(c(\"F\", \"M\", \"F\")), Courses = list(c(\"HPBBM\",\n    \"BD\", \"BIBMS\"), c(\"HPBBM\", \"MEB\", \"BIBMS\"), c(\"BD\", \"BQS\")),\n    Grades = list(c(7, 9, 8), c(5, 5, 6), c(10, 9)))\nStudents\n\n$Names\n[1] \"Ana\"  \"Juan\" \"Mar\" \n\n$Age\n[1] 20 20 21\n\n$Sex\n[1] F M F\nLevels: F M\n\n$Courses\n$Courses[[1]]\n[1] \"HPBBM\" \"BD\"    \"BIBMS\"\n\n$Courses[[2]]\n[1] \"HPBBM\" \"MEB\"   \"BIBMS\"\n\n$Courses[[3]]\n[1] \"BD\"  \"BQS\"\n\n\n$Grades\n$Grades[[1]]\n[1] 7 9 8\n\n$Grades[[2]]\n[1] 5 5 6\n\n$Grades[[3]]\n[1] 10  9\n\nstr(Students)  #shows the structure of the data object\n\nList of 5\n $ Names  : chr [1:3] \"Ana\" \"Juan\" \"Mar\"\n $ Age    : num [1:3] 20 20 21\n $ Sex    : Factor w/ 2 levels \"F\",\"M\": 1 2 1\n $ Courses:List of 3\n  ..$ : chr [1:3] \"HPBBM\" \"BD\" \"BIBMS\"\n  ..$ : chr [1:3] \"HPBBM\" \"MEB\" \"BIBMS\"\n  ..$ : chr [1:2] \"BD\" \"BQS\"\n $ Grades :List of 3\n  ..$ : num [1:3] 7 9 8\n  ..$ : num [1:3] 5 5 6\n  ..$ : num [1:2] 10 9\n\n# Accessing elements:\nStudents[[1]]\n\n[1] \"Ana\"  \"Juan\" \"Mar\" \n\nStudents$Names\n\n[1] \"Ana\"  \"Juan\" \"Mar\" \n\nStudents$Sex\n\n[1] F M F\nLevels: F M\n\nStudents[[4]]\n\n[[1]]\n[1] \"HPBBM\" \"BD\"    \"BIBMS\"\n\n[[2]]\n[1] \"HPBBM\" \"MEB\"   \"BIBMS\"\n\n[[3]]\n[1] \"BD\"  \"BQS\"\n\nStudents[[4]][[2]]\n\n[1] \"HPBBM\" \"MEB\"   \"BIBMS\"\n\nStudents[[4]][[2]][1]\n\n[1] \"HPBBM\""
  },
  {
    "objectID": "r2.html#nested-conditionals",
    "href": "r2.html#nested-conditionals",
    "title": "R2: Flow Control",
    "section": "2.1 Nested conditionals",
    "text": "2.1 Nested conditionals\nSometimes we need more than a single bifurcation in our code. For example, in the case above we may want to print negative when the number is less than zero,positive when it is more than zero and just zero when it is equal to zero. To do that can can just include (nest) an if-else structure within another if-else structure:\n\nx = readline(\"Enter a number:\")\n\nEnter a number:\n\ny = as.integer(x)\nif (y &lt; 0) {\n    print(\"negative\")\n} else {\n    if (y &gt; 0) {\n        print(\"positive\")\n    } else {\n        print(\"zero\")\n    }\n}\n\nError in if (y &lt; 0) {: missing value where TRUE/FALSE needed\n\nprint(\"End\")\n\n[1] \"End\""
  },
  {
    "objectID": "r2.html#another-way-to-code-nested-conditionals-else-if-statement",
    "href": "r2.html#another-way-to-code-nested-conditionals-else-if-statement",
    "title": "R2: Flow Control",
    "section": "2.2 Another way to code nested conditionals: else if statement",
    "text": "2.2 Another way to code nested conditionals: else if statement\nNesting is not restricted to three alternative blocks of code; in fact, we can nest as many if-else structures as necessary. However, the code becomes cumbersome with more that two or three blocks of code. For this reason, in situations where many blocks of code are to be conditionally executed it is much more convenient to use the else if (condition) statement. In this case, the conditional structure begins with and if(condition)statement and continues with as many else if (condition) statements as required. Finally, the structure may end with an else although it is not strictly required.\n\nx = readline(\"Enter a number:\")\n\nEnter a number:\n\ny = as.integer(x)\nif (y &lt; 0) {\n    print(\"negative\")\n} else if (y &gt; 0) {\n    print(\"positive\")\n} else {\n    print(\"zero\")\n}\n\nError in if (y &lt; 0) {: missing value where TRUE/FALSE needed\n\nprint(\"End\")\n\n[1] \"End\"\n\n\n\n\n\n\n\n\nPay Attention\n\n\n\nThe conditionals are evaluated sequentially in the order the appear un the code and once any of them results in TRUEthe remaining are skipped (not evaluated) and the code resumes execution after the whole conditional structure.\n\n\n\nx = readline(\"Age in years:\")\n\nAge in years:\n\ny = as.integer(x)\nif (y &lt; 0) {\n    print(\"Not born yet!\")\n} else if (y &lt; 1) {\n    print(\"Infant\")\n} else if (y &lt; 3) {\n    print(\"Toddler\")\n} else if (y &lt; 5) {\n    print(\"Preschooler\")\n} else if (y &lt; 9) {\n    print(\"Child\")\n} else if (y &lt; 13) {\n    print(\"Preteen\")\n} else if (y &lt; 18) {\n    print(\"Teenager\")\n} else if (y &lt; 25) {\n    print(\"Young Adult\")\n} else if (y &lt; 70) {\n    print(\"Adult\")\n} else if (y &lt; 100) {\n    print(\"Ederly/Senior\")\n} else {\n    print(\"Ancient!\")\n}\n\nError in if (y &lt; 0) {: missing value where TRUE/FALSE needed\n\n\nNote that, when coding many different conditionals the else if statement is much more convenient that nesting if-else structures. Also note that that conditionals are evaluated sequentially. For example, the following code is a variation of the previous one just changing the order of one of the conditionals and, as you can see it will not work as intended:\n\nprint(\"This script is WRONG!! \\n does not work as intended\")\n\n[1] \"This script is WRONG!! \\n does not work as intended\"\n\nx = readline(\"Age in years:\")\n\nAge in years:\n\ny = as.integer(x)\nif (y &lt; 0) {\n    print(\"Not born yet!\")\n} else if (y &lt; 100) {\n    print(\"Ederly/Senior\")\n} else if (y &lt; 3) {\n    print(\"Toddler\")\n} else if (y &lt; 5) {\n    print(\"Preschooler\")\n} else if (y &lt; 9) {\n    print(\"Child\")\n} else if (y &lt; 13) {\n    print(\"Preteen\")\n} else if (y &lt; 18) {\n    print(\"Teenager\")\n} else if (y &lt; 25) {\n    print(\"Young Adult\")\n} else if (y &lt; 70) {\n    print(\"Adult\")\n} else if (y &lt; 1) {\n    print(\"Infant\")\n} else {\n    print(\"Ancient!\")\n}\n\nError in if (y &lt; 0) {: missing value where TRUE/FALSE needed\n\n\nNotice that, in any type of conditional structure, you can combine multiple relational operators and, in the following particular example, it makes the case the order of the conditionals irrelevant:\n\nx = readline(\"Age in years:\")\n\nAge in years:\n\ny = as.integer(x)\nif (y &lt; 0) {\n    print(\"Not born yet!\")\n} else if (y &gt;= 70 & y &lt; 100) {\n    print(\"Ederly/Senior\")\n} else if (y &gt;= 1 & y &lt; 3) {\n    print(\"Toddler\")\n} else if (y &gt;= 3 & y &lt; 5) {\n    print(\"Preschooler\")\n} else if (y &gt;= 5 & y &lt; 9) {\n    print(\"Child\")\n} else if (y &gt;= 9 & y &lt; 13) {\n    print(\"Preteen\")\n} else if (y &gt;= 13 & y &lt; 18) {\n    print(\"Teenager\")\n} else if (y &gt;= 18 & y &lt; 25) {\n    print(\"Young Adult\")\n} else if (y &gt;= 25 & y &lt; 65) {\n    print(\"Adult\")\n} else if (y &gt;= 0 & y &lt; 1) {\n    print(\"Infant\")\n} else {\n    print(\"Ancient!\")\n}\n\nError in if (y &lt; 0) {: missing value where TRUE/FALSE needed"
  },
  {
    "objectID": "r2.html#a-vectorized-version-of-the-if-else-structures-ifelse-statement",
    "href": "r2.html#a-vectorized-version-of-the-if-else-structures-ifelse-statement",
    "title": "R2: Flow Control",
    "section": "2.3 A vectorized version of the if-else structures: ifelse statement",
    "text": "2.3 A vectorized version of the if-else structures: ifelse statement\nThe ifelse function in R is a vectorized version of the if-else statement, allowing you to perform conditional operations on entire vectors or arrays at once. It takes three arguments: the condition to evaluate, the value to return if the condition is true, and the value to return if the condition is false.\nFor example, in the examples above used to determine if a number was positive or negative, the code evaluated a single value at a time. The ifelse can evaluate multiple values simultaneously. That is, given a vector of numbers, the ifelse function can be used to return a vector indicating positive and negative values:\n\nMyNumbers &lt;- c(1, -3, 4, 5, -23)\nifelse(MyNumbers &gt; 0, \"Positive\", \"Negative\")\n\n[1] \"Positive\" \"Negative\" \"Positive\" \"Positive\" \"Negative\"\n\n\nIf more than one condition needs to be evaluated, the code could be modified to include as many ifelse as needed. For example the code below classify numbers as positive, negative or zero:\n\nMyNumbers &lt;- c(1, -3, 0, 5, -23)\nifelse(MyNumbers &gt; 0, \"Positive\", ifelse(MyNumbers &lt; 0, \"Negative\",\n    \"Zero\"))\n\n[1] \"Positive\" \"Negative\" \"Zero\"     \"Positive\" \"Negative\""
  },
  {
    "objectID": "r2.html#a-final-way-to-code-conditionals-switch-statement",
    "href": "r2.html#a-final-way-to-code-conditionals-switch-statement",
    "title": "R2: Flow Control",
    "section": "2.4 A final way to code conditionals: switch statement",
    "text": "2.4 A final way to code conditionals: switch statement\nThe code below asks the user to enter a DNA nucleotide using a single letter code (i.e the user enters A, C, G or T) and the program prints the full name of the base (i.e prints adenine, cytosine, guanine or thymine respectively) or NA if the user did not enter a nucleotide. Notice that the else clause handle any input other than the expected A, C,G or T; this is a typical use of the else statement.\n\nx = readline(\"Enter a nucleotide:\")\n\nEnter a nucleotide:\n\nx = toupper(x)  #just in case\nif (x == \"A\") {\n    print(\"adenine\")\n} else if (x == \"C\") {\n    print(\"cytosine\")\n} else if (x == \"G\") {\n    print(\"guanine\")\n} else if (x == \"T\") {\n    print(\"thymine\")\n} else {\n    print(NA)\n}\n\n[1] NA\n\n\nThis code can be also written using a less frequent but more compact conditional structure that uses the statement switch as shown in the code below\n\nx = readline(\"Enter a nucleotide:\")\n\nEnter a nucleotide:\n\nx = toupper(x)  #just in case!\nswitch(EXPR = x, A = \"adenine\", C = \"cytosine\", G = \"guanine\",\n    T = \"thymine\", NA)\n\n[1] NA\n\n\nPlease note that the switch statement matches the provided expression with the given cases exactly. It doesn’t perform logical evaluations like if-else statements, which check for conditions that evaluate to TRUE or FALSE."
  },
  {
    "objectID": "r2.html#for-loops",
    "href": "r2.html#for-loops",
    "title": "R2: Flow Control",
    "section": "3.1 for loops",
    "text": "3.1 for loops\nThe for loop is used when you know the exact number of iterations required. It iterates over a sequence, such as a vector or a range of numbers, executing a block of code for each iteration. For example, the code below calculates the square of each of the values in a matrix\n\nMyMat &lt;- matrix(1:9, ncol = 3)\nprint(MyMat)\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nMyMat3 &lt;- MyMat\nfor (rr in 1:dim(MyMat3)[1]) {\n    for (cc in 1:dim(MyMat3)[2]) {\n        MyMat3[rr, cc] &lt;- MyMat3[rr, cc]^2\n    }\n}\n\nprint(MyMat3)\n\n     [,1] [,2] [,3]\n[1,]    1   16   49\n[2,]    4   25   64\n[3,]    9   36   81\n\n\nNote that, thanks to the vectorization of data structures in R, this task can be accomplished in a single operation\n\nMyMat2 &lt;- MyMat^2\nprint(MyMat2)\n\n     [,1] [,2] [,3]\n[1,]    1   16   49\n[2,]    4   25   64\n[3,]    9   36   81"
  },
  {
    "objectID": "r2.html#while-loops",
    "href": "r2.html#while-loops",
    "title": "R2: Flow Control",
    "section": "3.2 while loops",
    "text": "3.2 while loops\n“While” loops are utilized to repeatedly execute a block of code (enclosed within curly brackets) as long as a specific condition remains true. The structure of a “while” loop includes a condition followed by a code block. The code block is executed iteratively until the condition evaluates to false. The computations within the code block may modify the state of the parameter being evaluated in the condition, leading to the program exiting the loop after a certain number of repetitions. The following code make use of while loops to generate a vector containing all 64 codons:\n\nNucl &lt;- LETTERS[c(1, 3, 7, 20)]\nCodons &lt;- c()\np1 &lt;- 1\nwhile (p1 &lt; 5) {\n    p2 &lt;- 1\n    while (p2 &lt; 5) {\n        p3 &lt;- 1\n        while (p3 &lt; 5) {\n            Codons &lt;- c(Codons, paste0(Nucl[p1], Nucl[p2], Nucl[p3]))\n            p3 &lt;- p3 + 1\n        }\n        p2 &lt;- p2 + 1\n    }\n    p1 &lt;- p1 + 1\n}\nprint(Codons)\n\n [1] \"AAA\" \"AAC\" \"AAG\" \"AAT\" \"ACA\" \"ACC\" \"ACG\" \"ACT\" \"AGA\" \"AGC\" \"AGG\" \"AGT\"\n[13] \"ATA\" \"ATC\" \"ATG\" \"ATT\" \"CAA\" \"CAC\" \"CAG\" \"CAT\" \"CCA\" \"CCC\" \"CCG\" \"CCT\"\n[25] \"CGA\" \"CGC\" \"CGG\" \"CGT\" \"CTA\" \"CTC\" \"CTG\" \"CTT\" \"GAA\" \"GAC\" \"GAG\" \"GAT\"\n[37] \"GCA\" \"GCC\" \"GCG\" \"GCT\" \"GGA\" \"GGC\" \"GGG\" \"GGT\" \"GTA\" \"GTC\" \"GTG\" \"GTT\"\n[49] \"TAA\" \"TAC\" \"TAG\" \"TAT\" \"TCA\" \"TCC\" \"TCG\" \"TCT\" \"TGA\" \"TGC\" \"TGG\" \"TGT\"\n[61] \"TTA\" \"TTC\" \"TTG\" \"TTT\""
  },
  {
    "objectID": "r2.html#control-flow-statements",
    "href": "r2.html#control-flow-statements",
    "title": "R2: Flow Control",
    "section": "3.3 Control flow statements",
    "text": "3.3 Control flow statements\nSometimes, it may be necessary for a program to skip executing a block of code (or part of it) and move to the next iteration. In other cases, the program may need to exit the loop prematurely if a certain condition is met. To achieve these actions, we can use the next and break statements, respectively. Both control statements are typically invoked within a conditional context. For instance, when computing the Shannon Entropy (\\(H(X)=\\sum_i P(x_i) log(Pi)\\)) of a variable’s state distribution, it is common to skip terms with a frequency of zero to avoid encountering the undefined value of \\(log(0)\\). Consider the following code, which takes a vector representing the observed absolute frequencies of nucleotides at a specific genomic position and calculates the Shannon Entropy for that position:\nIn this code, the next statement is used to skip the calculation of terms with a frequency of zero. This prevents the program from encountering the undefined \\(\\log(0)\\) value. The loop continues to the next iteration and calculates the entropy based on non-zero frequencies.\n\nNucleotide_frequencies &lt;- c(25, 0, 5, 0)  #example of absolute frequencies of A, C, G and T\nTotal_Freq &lt;- sum(Nucleotide_frequencies)\nEntropy &lt;- 0\nfor (Freq in Nucleotide_frequencies) {\n    if (Freq == 0) {\n        next  #skips the remaining of the block and goes to next iteration\n    }\n    Prob &lt;- Freq/Total_Freq\n    Entropy &lt;- Entropy + (Prob * log2(Prob))\n}\nEntropy &lt;- (-1) * Entropy\nprint(Entropy)\n\n[1] 0.6500224\n\n\nBy utilizing the next statement, we ensure that the Shannon Entropy computation proceeds correctly without encountering any issues related to zero frequencies."
  },
  {
    "objectID": "r2.html#repeat-loops",
    "href": "r2.html#repeat-loops",
    "title": "R2: Flow Control",
    "section": "3.4 repeat loops",
    "text": "3.4 repeat loops\nAn additional statement in R that allows you to execute a block of code a specific number of times is called repeat. Similar to while loops, the block of code within the repeat statement is repeated until a certain condition is met. However, unlike while loops, the condition itself is not specified within the repeat statement. Instead, the condition is part of the code block, and the loop is terminated using the break statement when the condition is satisfied. For example, the following code prints the Fibonacci terms smaller than 250:\n\nFib &lt;- c(1, 1)\nrepeat {\n    tmp &lt;- Fib[length(Fib) - 1] + Fib[length(Fib)]\n    if (tmp &gt; 250) {\n        break\n    }\n    Fib &lt;- c(Fib, tmp)\n}\nprint(Fib)\n\n [1]   1   1   2   3   5   8  13  21  34  55  89 144 233"
  }
]